{"title":"现代图形 API","date":"2025-11-30T14:38:03.000Z","toc":true,"summary":"现代图形 API 综述","source":"_posts/现代图形-API.md","raw":"---\ntitle: 现代图形 API\ndate: 2025-11-30 22:38:03\ntags: Graphics\ntoc: true\nsummary: \"现代图形 API 综述\"\n---\n\n# 1. Introducation\n\n图形 API 是一套预定义的函数、数据结构、协议和工具的集合。它是连接应用程序和图形硬件的桥梁。\n\n>图形 API 规定了应用程序如何向 GPU 发出命令，以及 GPU 需要提供哪些功能。基于这份相同的协议， GPU 制造商和应用程序的开发者开发的产品就能兼容。\n>\n>如果没有图形 API，那么意味着开发者不得不为每一款特定的 GPU 编写机器码，这是难以想象的。\n\n通常，图形 API 通过管理以下内容，协同完成从数据到图像的转换：\n\n1. 资源\n\n   - 资源指所有需要送入 GPU 处理的数据，包括几何数据（顶点、索引）、纹理、着色器程序等\n   - 图形 API 提供接口，让应用程序在 GPU 上创建、填充、销毁这些资源，并管理它们在 GPU 内存中的分配与布局\n\n2. 着色器\n\n   - 着色器是运行在GPU上的微型程序，是渲染管线的可编程核心\n   - 图形 API 提供专用的着色器语言，并负责将开发者编写的着色器代码编译成 GPU  能理解的二进制格式，最终链接成一个完整的着色器程序供管线使用\n\n3. 渲染管线与状态机\n\n   - 渲染管线是一个固定的、可配置的流水线，定义了从顶点数据到像素的处理步骤\n\n   - 图形 API 允许开发者配置流水线。包括绑定着色器、设置固定功能状态（如深度测试、混合模式）、绑定资源（如纹理）等。这些配置构成了一个状态机，现代图形 API 往往要求开发者将大部分管线状态预先打包成一个管线状态对象，以提升效率\n\n     >广义状态机：其后续输出依赖于之前设置的上下文（状态），都可以被视为状态机。\n     >\n     >传统图形 API 如 OpenGL 等是一种单一的、全局的、隐式管理的巨型状态机，易用但危险，开销较大。\n     >\n     >而现代图形 API 如 Vulkan 将状态打散、显式化，分离成多个离散的、可预编译的状态对象（如 `VkPipeline` ）\n\n4. 命令提交与同步\n\n   - 命名提交是 CPU 向 GPU 发送绘制指令的过程，由于 CPU 和 GPU 是独立、异步工作的，必须妥善处理它们之间的协同。\n   - 图形 API 主要提供两种机制处理命令提交与同步：\n     - 命令缓冲区：让 GPU 提前将一系列绘制命令录制到缓冲区中（可在多个线程上并发录制），然后高效地一次性提交给 GPU 执行\n     - 同步对象：提供栅栏、信号量等工具，确保 GPU 不会在 CPU 完成数据写入前就开始读取，或者不会在上一帧完成渲染前就开始下一帧的渲染，防止数据竞争和视觉错误\n\n传统的图形 API 如 OpenGL，DirectX11 等秉承高抽象、易用的设计哲学，在减轻开发者负担的同时也带来了不可预测的性能开销。\n\n而现代图形 API 如 Vulkan，DirectX12，Metal，WebGPU 等要求开发者必须显式声明和管理一切，使得 CPU 的开销变得可预测。","slug":"现代图形-API","published":true,"updated":"2025-12-02T15:50:54.302Z","_id":"cmiltx92h000040cn51xc2jf4","comments":true,"layout":"post","photos":[],"html":"<h1>1. Introducation</h1>\n<p>图形 API 是一套预定义的函数、数据结构、协议和工具的集合。它是连接应用程序和图形硬件的桥梁。</p>\n<blockquote>\n<p>图形 API 规定了应用程序如何向 GPU 发出命令，以及 GPU 需要提供哪些功能。基于这份相同的协议， GPU 制造商和应用程序的开发者开发的产品就能兼容。</p>\n<p>如果没有图形 API，那么意味着开发者不得不为每一款特定的 GPU 编写机器码，这是难以想象的。</p>\n</blockquote>\n<p>通常，图形 API 通过管理以下内容，协同完成从数据到图像的转换：</p>\n<ol>\n<li>\n<p>资源</p>\n<ul>\n<li>资源指所有需要送入 GPU 处理的数据，包括几何数据（顶点、索引）、纹理、着色器程序等</li>\n<li>图形 API 提供接口，让应用程序在 GPU 上创建、填充、销毁这些资源，并管理它们在 GPU 内存中的分配与布局</li>\n</ul>\n</li>\n<li>\n<p>着色器</p>\n<ul>\n<li>着色器是运行在GPU上的微型程序，是渲染管线的可编程核心</li>\n<li>图形 API 提供专用的着色器语言，并负责将开发者编写的着色器代码编译成 GPU  能理解的二进制格式，最终链接成一个完整的着色器程序供管线使用</li>\n</ul>\n</li>\n<li>\n<p>渲染管线与状态机</p>\n<ul>\n<li>\n<p>渲染管线是一个固定的、可配置的流水线，定义了从顶点数据到像素的处理步骤</p>\n</li>\n<li>\n<p>图形 API 允许开发者配置流水线。包括绑定着色器、设置固定功能状态（如深度测试、混合模式）、绑定资源（如纹理）等。这些配置构成了一个状态机，现代图形 API 往往要求开发者将大部分管线状态预先打包成一个管线状态对象，以提升效率</p>\n<blockquote>\n<p>广义状态机：其后续输出依赖于之前设置的上下文（状态），都可以被视为状态机。</p>\n<p>传统图形 API 如 OpenGL 等是一种单一的、全局的、隐式管理的巨型状态机，易用但危险，开销较大。</p>\n<p>而现代图形 API 如 Vulkan 将状态打散、显式化，分离成多个离散的、可预编译的状态对象（如 <code>VkPipeline</code> ）</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>命令提交与同步</p>\n<ul>\n<li>命名提交是 CPU 向 GPU 发送绘制指令的过程，由于 CPU 和 GPU 是独立、异步工作的，必须妥善处理它们之间的协同。</li>\n<li>图形 API 主要提供两种机制处理命令提交与同步：\n<ul>\n<li>命令缓冲区：让 GPU 提前将一系列绘制命令录制到缓冲区中（可在多个线程上并发录制），然后高效地一次性提交给 GPU 执行</li>\n<li>同步对象：提供栅栏、信号量等工具，确保 GPU 不会在 CPU 完成数据写入前就开始读取，或者不会在上一帧完成渲染前就开始下一帧的渲染，防止数据竞争和视觉错误</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>传统的图形 API 如 OpenGL，DirectX11 等秉承高抽象、易用的设计哲学，在减轻开发者负担的同时也带来了不可预测的性能开销。</p>\n<p>而现代图形 API 如 Vulkan，DirectX12，Metal，WebGPU 等要求开发者必须显式声明和管理一切，使得 CPU 的开销变得可预测。</p>\n","excerpt":"","more":"<h1>1. Introducation</h1>\n<p>图形 API 是一套预定义的函数、数据结构、协议和工具的集合。它是连接应用程序和图形硬件的桥梁。</p>\n<blockquote>\n<p>图形 API 规定了应用程序如何向 GPU 发出命令，以及 GPU 需要提供哪些功能。基于这份相同的协议， GPU 制造商和应用程序的开发者开发的产品就能兼容。</p>\n<p>如果没有图形 API，那么意味着开发者不得不为每一款特定的 GPU 编写机器码，这是难以想象的。</p>\n</blockquote>\n<p>通常，图形 API 通过管理以下内容，协同完成从数据到图像的转换：</p>\n<ol>\n<li>\n<p>资源</p>\n<ul>\n<li>资源指所有需要送入 GPU 处理的数据，包括几何数据（顶点、索引）、纹理、着色器程序等</li>\n<li>图形 API 提供接口，让应用程序在 GPU 上创建、填充、销毁这些资源，并管理它们在 GPU 内存中的分配与布局</li>\n</ul>\n</li>\n<li>\n<p>着色器</p>\n<ul>\n<li>着色器是运行在GPU上的微型程序，是渲染管线的可编程核心</li>\n<li>图形 API 提供专用的着色器语言，并负责将开发者编写的着色器代码编译成 GPU  能理解的二进制格式，最终链接成一个完整的着色器程序供管线使用</li>\n</ul>\n</li>\n<li>\n<p>渲染管线与状态机</p>\n<ul>\n<li>\n<p>渲染管线是一个固定的、可配置的流水线，定义了从顶点数据到像素的处理步骤</p>\n</li>\n<li>\n<p>图形 API 允许开发者配置流水线。包括绑定着色器、设置固定功能状态（如深度测试、混合模式）、绑定资源（如纹理）等。这些配置构成了一个状态机，现代图形 API 往往要求开发者将大部分管线状态预先打包成一个管线状态对象，以提升效率</p>\n<blockquote>\n<p>广义状态机：其后续输出依赖于之前设置的上下文（状态），都可以被视为状态机。</p>\n<p>传统图形 API 如 OpenGL 等是一种单一的、全局的、隐式管理的巨型状态机，易用但危险，开销较大。</p>\n<p>而现代图形 API 如 Vulkan 将状态打散、显式化，分离成多个离散的、可预编译的状态对象（如 <code>VkPipeline</code> ）</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>命令提交与同步</p>\n<ul>\n<li>命名提交是 CPU 向 GPU 发送绘制指令的过程，由于 CPU 和 GPU 是独立、异步工作的，必须妥善处理它们之间的协同。</li>\n<li>图形 API 主要提供两种机制处理命令提交与同步：\n<ul>\n<li>命令缓冲区：让 GPU 提前将一系列绘制命令录制到缓冲区中（可在多个线程上并发录制），然后高效地一次性提交给 GPU 执行</li>\n<li>同步对象：提供栅栏、信号量等工具，确保 GPU 不会在 CPU 完成数据写入前就开始读取，或者不会在上一帧完成渲染前就开始下一帧的渲染，防止数据竞争和视觉错误</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>传统的图形 API 如 OpenGL，DirectX11 等秉承高抽象、易用的设计哲学，在减轻开发者负担的同时也带来了不可预测的性能开销。</p>\n<p>而现代图形 API 如 Vulkan，DirectX12，Metal，WebGPU 等要求开发者必须显式声明和管理一切，使得 CPU 的开销变得可预测。</p>\n","path":"2025/11/30/现代图形-API/","permalink":"https://zweireverberate.space/2025/11/30/%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%BD%A2-API/","tags":[{"name":"Graphics","_id":"cmiltx92m000140cn5ew9erx3","slug":"Graphics","path":"tags/Graphics/","permalink":"https://zweireverberate.space/tags/Graphics/","length":1}],"categories":[],"prev":{"title":"素影微行","date":"2989-06-04T06:36:24.000Z","summary":"随笔","slug":"素影微行","published":true,"updated":"2025-07-14T15:13:50.317Z","_id":"cmefcsga500017gcn3f043goh","layout":"post","photos":[],"excerpt":"","path":"2989/06/04/素影微行/","permalink":"https://zweireverberate.space/2989/06/04/%E7%B4%A0%E5%BD%B1%E5%BE%AE%E8%A1%8C/","__post":true},"next":{"title":"C++ General","date":"2025-11-09T14:59:09.000Z","summary":"C++ 通义","slug":"C-General","published":true,"updated":"2025-11-23T08:30:45.270Z","_id":"cmhrudxky00005kcn5jz2f7fa","layout":"post","photos":[],"excerpt":"","path":"2025/11/09/C-General/","permalink":"https://zweireverberate.space/2025/11/09/C-General/","__post":true},"__post":true}