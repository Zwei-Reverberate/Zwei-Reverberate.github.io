{"title":"现代图形 API","date":"2025-11-30T14:38:03.000Z","toc":true,"summary":"现代图形 API 综述","source":"_posts/现代图形-API.md","raw":"---\ntitle: 现代图形 API\ndate: 2025-11-30 22:38:03\ntags: Graphics\ntoc: true\nsummary: \"现代图形 API 综述\"\n---\n\n# 1. Introducation\n\n图形 API 是一套预定义的函数、数据结构、协议和工具的集合。它是连接应用程序和图形硬件的桥梁。\n\n>图形 API 规定了应用程序如何向 GPU 发出命令，以及 GPU 需要提供哪些功能。基于这份相同的协议， GPU 制造商和应用程序的开发者开发的产品就能兼容。\n>\n>如果没有图形 API，那么意味着开发者不得不为每一款特定的 GPU 编写机器码，这是难以想象的。\n\n通常，图形 API 通过管理以下内容，协同完成从数据到图像的转换：\n\n1. 资源\n\n   - 资源指所有需要送入 GPU 处理的数据，包括几何数据（顶点、索引）、纹理、着色器程序等\n   - 图形 API 提供接口，让应用程序在 GPU 上创建、填充、销毁这些资源，并管理它们在 GPU 内存中的分配与布局\n\n2. 着色器\n\n   - 着色器是运行在GPU上的微型程序，是渲染管线的可编程核心\n   - 图形 API 提供专用的着色器语言，并负责将开发者编写的着色器代码编译成 GPU  能理解的二进制格式，最终链接成一个完整的着色器程序供管线使用\n\n3. 渲染管线与状态机\n\n   - 渲染管线是一个固定的、可配置的流水线，定义了从顶点数据到像素的处理步骤\n\n   - 图形 API 允许开发者配置流水线。包括绑定着色器、设置固定功能状态（如深度测试、混合模式）、绑定资源（如纹理）等。这些配置构成了一个状态机，现代图形 API 往往要求开发者将大部分管线状态预先打包成一个管线状态对象，以提升效率\n\n     >广义状态机：其后续输出依赖于之前设置的上下文（状态），都可以被视为状态机。\n     >\n     >传统图形 API 如 OpenGL 等是一种单一的、全局的、隐式管理的巨型状态机，易用但危险，开销较大。\n     >\n     >而现代图形 API 如 Vulkan 将状态打散、显式化，分离成多个离散的、可预编译的状态对象（如 `VkPipeline` ）\n\n4. 命令提交与同步\n\n   - 命名提交是 CPU 向 GPU 发送绘制指令的过程，由于 CPU 和 GPU 是独立、异步工作的，必须妥善处理它们之间的协同。\n   - 图形 API 主要提供两种机制处理命令提交与同步：\n     - 命令缓冲区：让 GPU 提前将一系列绘制命令录制到缓冲区中（可在多个线程上并发录制），然后高效地一次性提交给 GPU 执行\n     - 同步对象：提供栅栏、信号量等工具，确保 GPU 不会在 CPU 完成数据写入前就开始读取，或者不会在上一帧完成渲染前就开始下一帧的渲染，防止数据竞争和视觉错误\n\n传统的图形 API 如 OpenGL，DirectX11 等秉承高抽象、易用的设计哲学，在减轻开发者负担的同时也带来了不可预测的性能开销。\n\n而现代图形 API 如 Vulkan，DirectX12，Metal，WebGPU 等要求开发者必须显式声明和管理一切，使得 CPU 的开销变得可预测。\n\n&nbsp;\n\n# 2. Physical Device\n\n在现代图形 API 中，Physical Device（物理设备）指的是图形处理器硬件——显卡。\n\n传统图形 API 高度抽象化，由驱动程序管理底层细节（内存，同步，多 GPU 等）。而现代图形 API 将控制权交还给开发者，为了实现这一点，首先需要暴露硬件本身，Physical Device 就是这个这个暴露的接口，开发者可以查询物理设备的信息，如支持特性、资源限制等。\n\n当查询一个 Physical Device 时，主要获取以下几类关键信息：\n\n1. 属性与标识：\n\n   - 设备名称（如 \"NVIDIA GeForce RTX 4080\"）、供应商ID（Vendor ID)、设备ID\n   - API 版本、驱动程序版本\n   - 设备类型：集成显卡（`INTEGRATED_GPU`）、独立显卡（`DISCRETE_GPU`）、虚拟GPU还是CPU\n\n2. 功能特性\n\n   - 图形管线特性：支持哪些着色器阶段、顶点/实现属性上限等\n   - 计算能力：支持的计算着色器工作组大小等\n   - 可选功能：API 核心规范只保证一个最低标准，所有的高级功能（如几何着色器，曲面细分，条件渲染，片段存储读写，光线追踪，网格着色器）都以特性或者拓展的形式给出，开发者需要显式查询并启用特定的功能\n   - 纹理/缓冲区格式支持：哪些像素格式可用于渲染、采样或存储\n\n3. 队列家族（Queue Families）\n\n   - 队列家族揭示了 GPU 内部的并行执行架构，一个物理设备包含多个队列家族，每个家族专精于不同类型的工作负载（图形绘制，通用计算，异步数据传输，视频编解码）\n   - 查询结果包括：\n     - 每个家族支持的操作类型（`GRAPHICS`, `COMPUTE`, `TRANSFER`, `SPARSE_BINDING`等）\n     - 每个家族可用的队列数量，这决定了可并行提交的任务流数量\n     - 每个家族是否支持与特定的显示表面进行呈现操作（Presentation）\n   -  正确的队列选择是并行渲染、计算与传输重叠的关键\n\n4. 内存属性\n\n   物理设备将内存组织为内存堆和内存类型：\n\n   - 内存堆：代表物理内存池（如独立的显存、共享的系统内存）。查询会提供每个堆的大小和标志\n   - 内存类型：存在于堆中，是具有特定属性组合的逻辑划分，如：\n\n     - `DEVICE_LOCAL_BIT`：设备本地，访问速度最快，适合纹理和顶点缓冲区\n\n     - `HOST_VISIBLE_BIT`：主机（CPU）可见，适合频繁更新的动态数据。\n    \n     - `HOST_COHERENT_BIT`：CPU与GPU缓存自动保持一致，简化操作但可能牺牲性能。\n    \n     - `HOST_CACHED_BIT`：主机端缓存，适合CPU随机读取的数据\n   - 根据资源访问模式选择正确的内存类型（如将常变数据放在`HOST_VISIBLE`内存中，将静态纹理放在`DEVICE_LOCAL`内存中）是应遵循的性能优化原则\n\n5. 格式支持\n\n   查询特定纹理或缓冲区格式，对于给定的像素格式（如 `VK_FORMAT_R8G8B8A8_UNORM`）检查其支持的特性：\n\n   - `SAMPLED_IMAGE`：能否在着色器中采样。\n\n   - `STORAGE_IMAGE`：能否在计算着色器中作为存储图像读写。\n\n   - `COLOR_ATTACHMENT`：能否作为渲染目标。\n\n   - `BLEND`：在作为渲染目标时是否支持混合\n\n6. 交换链支持\n\n   此支持并非核心 API 的一部分，而是通过扩展实现。\n\n   - 确认设备支持所需的窗口系统集成拓展（如 `VK_KHR_swapchain`）\n   - 查询设备与特定窗口表面的兼容性，包括\n     - 支持的表面格式（像素格式，色彩空间）\n     - 可用的呈现模式（立即模式、垂直同步 `FIFO`、无撕裂的 `MAILBOX` 等）\n     - 表面能力（最小/最大图像数量、当前交换链图像分辨率范围等）\n\n7. 高级架构特性\n\n   - 多GPU支持：设备组（device groups）和链接设备（linked devices）的能力，用于协同多个GPU\n   - 管线缓存：通过 `pipelineCacheUUID` 实现跨进程的管线缓存，加速管线创建\n   - 稀疏内存：支持稀疏纹理和缓冲区，允许部分 residency 和动态映射，适用于流式加载大型纹理\n   - 保守光栅化（Conservative Rasterization）、光栅顺序视图（Rasterization Order View）等高级渲染特性\n   - 子组（Subgroup）操作：支持Wave操作，对计算着色器优化至关重要\n   - 性能查询：支持时间戳和性能查询，用于性能分析\n\n&nbsp;\n\n# 3. Logical Device\n\n","slug":"现代图形-API","published":true,"updated":"2025-12-11T14:52:01.638Z","_id":"cmiltx92h000040cn51xc2jf4","comments":true,"layout":"post","photos":[],"html":"<h1>1. Introducation</h1>\n<p>图形 API 是一套预定义的函数、数据结构、协议和工具的集合。它是连接应用程序和图形硬件的桥梁。</p>\n<blockquote>\n<p>图形 API 规定了应用程序如何向 GPU 发出命令，以及 GPU 需要提供哪些功能。基于这份相同的协议， GPU 制造商和应用程序的开发者开发的产品就能兼容。</p>\n<p>如果没有图形 API，那么意味着开发者不得不为每一款特定的 GPU 编写机器码，这是难以想象的。</p>\n</blockquote>\n<p>通常，图形 API 通过管理以下内容，协同完成从数据到图像的转换：</p>\n<ol>\n<li>\n<p>资源</p>\n<ul>\n<li>资源指所有需要送入 GPU 处理的数据，包括几何数据（顶点、索引）、纹理、着色器程序等</li>\n<li>图形 API 提供接口，让应用程序在 GPU 上创建、填充、销毁这些资源，并管理它们在 GPU 内存中的分配与布局</li>\n</ul>\n</li>\n<li>\n<p>着色器</p>\n<ul>\n<li>着色器是运行在GPU上的微型程序，是渲染管线的可编程核心</li>\n<li>图形 API 提供专用的着色器语言，并负责将开发者编写的着色器代码编译成 GPU  能理解的二进制格式，最终链接成一个完整的着色器程序供管线使用</li>\n</ul>\n</li>\n<li>\n<p>渲染管线与状态机</p>\n<ul>\n<li>\n<p>渲染管线是一个固定的、可配置的流水线，定义了从顶点数据到像素的处理步骤</p>\n</li>\n<li>\n<p>图形 API 允许开发者配置流水线。包括绑定着色器、设置固定功能状态（如深度测试、混合模式）、绑定资源（如纹理）等。这些配置构成了一个状态机，现代图形 API 往往要求开发者将大部分管线状态预先打包成一个管线状态对象，以提升效率</p>\n<blockquote>\n<p>广义状态机：其后续输出依赖于之前设置的上下文（状态），都可以被视为状态机。</p>\n<p>传统图形 API 如 OpenGL 等是一种单一的、全局的、隐式管理的巨型状态机，易用但危险，开销较大。</p>\n<p>而现代图形 API 如 Vulkan 将状态打散、显式化，分离成多个离散的、可预编译的状态对象（如 <code>VkPipeline</code> ）</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>命令提交与同步</p>\n<ul>\n<li>命名提交是 CPU 向 GPU 发送绘制指令的过程，由于 CPU 和 GPU 是独立、异步工作的，必须妥善处理它们之间的协同。</li>\n<li>图形 API 主要提供两种机制处理命令提交与同步：\n<ul>\n<li>命令缓冲区：让 GPU 提前将一系列绘制命令录制到缓冲区中（可在多个线程上并发录制），然后高效地一次性提交给 GPU 执行</li>\n<li>同步对象：提供栅栏、信号量等工具，确保 GPU 不会在 CPU 完成数据写入前就开始读取，或者不会在上一帧完成渲染前就开始下一帧的渲染，防止数据竞争和视觉错误</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>传统的图形 API 如 OpenGL，DirectX11 等秉承高抽象、易用的设计哲学，在减轻开发者负担的同时也带来了不可预测的性能开销。</p>\n<p>而现代图形 API 如 Vulkan，DirectX12，Metal，WebGPU 等要求开发者必须显式声明和管理一切，使得 CPU 的开销变得可预测。</p>\n<p> </p>\n<h1>2. Physical Device</h1>\n<p>在现代图形 API 中，Physical Device（物理设备）指的是图形处理器硬件——显卡。</p>\n<p>传统图形 API 高度抽象化，由驱动程序管理底层细节（内存，同步，多 GPU 等）。而现代图形 API 将控制权交还给开发者，为了实现这一点，首先需要暴露硬件本身，Physical Device 就是这个这个暴露的接口，开发者可以查询物理设备的信息，如支持特性、资源限制等。</p>\n<p>当查询一个 Physical Device 时，主要获取以下几类关键信息：</p>\n<ol>\n<li>\n<p>属性与标识：</p>\n<ul>\n<li>设备名称（如 “NVIDIA GeForce RTX 4080”）、供应商ID（Vendor ID)、设备ID</li>\n<li>API 版本、驱动程序版本</li>\n<li>设备类型：集成显卡（<code>INTEGRATED_GPU</code>）、独立显卡（<code>DISCRETE_GPU</code>）、虚拟GPU还是CPU</li>\n</ul>\n</li>\n<li>\n<p>功能特性</p>\n<ul>\n<li>图形管线特性：支持哪些着色器阶段、顶点/实现属性上限等</li>\n<li>计算能力：支持的计算着色器工作组大小等</li>\n<li>可选功能：API 核心规范只保证一个最低标准，所有的高级功能（如几何着色器，曲面细分，条件渲染，片段存储读写，光线追踪，网格着色器）都以特性或者拓展的形式给出，开发者需要显式查询并启用特定的功能</li>\n<li>纹理/缓冲区格式支持：哪些像素格式可用于渲染、采样或存储</li>\n</ul>\n</li>\n<li>\n<p>队列家族（Queue Families）</p>\n<ul>\n<li>队列家族揭示了 GPU 内部的并行执行架构，一个物理设备包含多个队列家族，每个家族专精于不同类型的工作负载（图形绘制，通用计算，异步数据传输，视频编解码）</li>\n<li>查询结果包括：\n<ul>\n<li>每个家族支持的操作类型（<code>GRAPHICS</code>, <code>COMPUTE</code>, <code>TRANSFER</code>, <code>SPARSE_BINDING</code>等）</li>\n<li>每个家族可用的队列数量，这决定了可并行提交的任务流数量</li>\n<li>每个家族是否支持与特定的显示表面进行呈现操作（Presentation）</li>\n</ul>\n</li>\n<li>正确的队列选择是并行渲染、计算与传输重叠的关键</li>\n</ul>\n</li>\n<li>\n<p>内存属性</p>\n<p>物理设备将内存组织为内存堆和内存类型：</p>\n<ul>\n<li>\n<p>内存堆：代表物理内存池（如独立的显存、共享的系统内存）。查询会提供每个堆的大小和标志</p>\n</li>\n<li>\n<p>内存类型：存在于堆中，是具有特定属性组合的逻辑划分，如：</p>\n<ul>\n<li>\n<p><code>DEVICE_LOCAL_BIT</code>：设备本地，访问速度最快，适合纹理和顶点缓冲区</p>\n</li>\n<li>\n<p><code>HOST_VISIBLE_BIT</code>：主机（CPU）可见，适合频繁更新的动态数据。</p>\n</li>\n<li>\n<p><code>HOST_COHERENT_BIT</code>：CPU与GPU缓存自动保持一致，简化操作但可能牺牲性能。</p>\n</li>\n<li>\n<p><code>HOST_CACHED_BIT</code>：主机端缓存，适合CPU随机读取的数据</p>\n</li>\n</ul>\n</li>\n<li>\n<p>根据资源访问模式选择正确的内存类型（如将常变数据放在<code>HOST_VISIBLE</code>内存中，将静态纹理放在<code>DEVICE_LOCAL</code>内存中）是应遵循的性能优化原则</p>\n</li>\n</ul>\n</li>\n<li>\n<p>格式支持</p>\n<p>查询特定纹理或缓冲区格式，对于给定的像素格式（如 <code>VK_FORMAT_R8G8B8A8_UNORM</code>）检查其支持的特性：</p>\n<ul>\n<li>\n<p><code>SAMPLED_IMAGE</code>：能否在着色器中采样。</p>\n</li>\n<li>\n<p><code>STORAGE_IMAGE</code>：能否在计算着色器中作为存储图像读写。</p>\n</li>\n<li>\n<p><code>COLOR_ATTACHMENT</code>：能否作为渲染目标。</p>\n</li>\n<li>\n<p><code>BLEND</code>：在作为渲染目标时是否支持混合</p>\n</li>\n</ul>\n</li>\n<li>\n<p>交换链支持</p>\n<p>此支持并非核心 API 的一部分，而是通过扩展实现。</p>\n<ul>\n<li>确认设备支持所需的窗口系统集成拓展（如 <code>VK_KHR_swapchain</code>）</li>\n<li>查询设备与特定窗口表面的兼容性，包括\n<ul>\n<li>支持的表面格式（像素格式，色彩空间）</li>\n<li>可用的呈现模式（立即模式、垂直同步 <code>FIFO</code>、无撕裂的 <code>MAILBOX</code> 等）</li>\n<li>表面能力（最小/最大图像数量、当前交换链图像分辨率范围等）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>高级架构特性</p>\n<ul>\n<li>多GPU支持：设备组（device groups）和链接设备（linked devices）的能力，用于协同多个GPU</li>\n<li>管线缓存：通过 <code>pipelineCacheUUID</code> 实现跨进程的管线缓存，加速管线创建</li>\n<li>稀疏内存：支持稀疏纹理和缓冲区，允许部分 residency 和动态映射，适用于流式加载大型纹理</li>\n<li>保守光栅化（Conservative Rasterization）、光栅顺序视图（Rasterization Order View）等高级渲染特性</li>\n<li>子组（Subgroup）操作：支持Wave操作，对计算着色器优化至关重要</li>\n<li>性能查询：支持时间戳和性能查询，用于性能分析</li>\n</ul>\n</li>\n</ol>\n<p> </p>\n<h1>3. Logical Device</h1>\n","excerpt":"","more":"<h1>1. Introducation</h1>\n<p>图形 API 是一套预定义的函数、数据结构、协议和工具的集合。它是连接应用程序和图形硬件的桥梁。</p>\n<blockquote>\n<p>图形 API 规定了应用程序如何向 GPU 发出命令，以及 GPU 需要提供哪些功能。基于这份相同的协议， GPU 制造商和应用程序的开发者开发的产品就能兼容。</p>\n<p>如果没有图形 API，那么意味着开发者不得不为每一款特定的 GPU 编写机器码，这是难以想象的。</p>\n</blockquote>\n<p>通常，图形 API 通过管理以下内容，协同完成从数据到图像的转换：</p>\n<ol>\n<li>\n<p>资源</p>\n<ul>\n<li>资源指所有需要送入 GPU 处理的数据，包括几何数据（顶点、索引）、纹理、着色器程序等</li>\n<li>图形 API 提供接口，让应用程序在 GPU 上创建、填充、销毁这些资源，并管理它们在 GPU 内存中的分配与布局</li>\n</ul>\n</li>\n<li>\n<p>着色器</p>\n<ul>\n<li>着色器是运行在GPU上的微型程序，是渲染管线的可编程核心</li>\n<li>图形 API 提供专用的着色器语言，并负责将开发者编写的着色器代码编译成 GPU  能理解的二进制格式，最终链接成一个完整的着色器程序供管线使用</li>\n</ul>\n</li>\n<li>\n<p>渲染管线与状态机</p>\n<ul>\n<li>\n<p>渲染管线是一个固定的、可配置的流水线，定义了从顶点数据到像素的处理步骤</p>\n</li>\n<li>\n<p>图形 API 允许开发者配置流水线。包括绑定着色器、设置固定功能状态（如深度测试、混合模式）、绑定资源（如纹理）等。这些配置构成了一个状态机，现代图形 API 往往要求开发者将大部分管线状态预先打包成一个管线状态对象，以提升效率</p>\n<blockquote>\n<p>广义状态机：其后续输出依赖于之前设置的上下文（状态），都可以被视为状态机。</p>\n<p>传统图形 API 如 OpenGL 等是一种单一的、全局的、隐式管理的巨型状态机，易用但危险，开销较大。</p>\n<p>而现代图形 API 如 Vulkan 将状态打散、显式化，分离成多个离散的、可预编译的状态对象（如 <code>VkPipeline</code> ）</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>命令提交与同步</p>\n<ul>\n<li>命名提交是 CPU 向 GPU 发送绘制指令的过程，由于 CPU 和 GPU 是独立、异步工作的，必须妥善处理它们之间的协同。</li>\n<li>图形 API 主要提供两种机制处理命令提交与同步：\n<ul>\n<li>命令缓冲区：让 GPU 提前将一系列绘制命令录制到缓冲区中（可在多个线程上并发录制），然后高效地一次性提交给 GPU 执行</li>\n<li>同步对象：提供栅栏、信号量等工具，确保 GPU 不会在 CPU 完成数据写入前就开始读取，或者不会在上一帧完成渲染前就开始下一帧的渲染，防止数据竞争和视觉错误</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>传统的图形 API 如 OpenGL，DirectX11 等秉承高抽象、易用的设计哲学，在减轻开发者负担的同时也带来了不可预测的性能开销。</p>\n<p>而现代图形 API 如 Vulkan，DirectX12，Metal，WebGPU 等要求开发者必须显式声明和管理一切，使得 CPU 的开销变得可预测。</p>\n<p> </p>\n<h1>2. Physical Device</h1>\n<p>在现代图形 API 中，Physical Device（物理设备）指的是图形处理器硬件——显卡。</p>\n<p>传统图形 API 高度抽象化，由驱动程序管理底层细节（内存，同步，多 GPU 等）。而现代图形 API 将控制权交还给开发者，为了实现这一点，首先需要暴露硬件本身，Physical Device 就是这个这个暴露的接口，开发者可以查询物理设备的信息，如支持特性、资源限制等。</p>\n<p>当查询一个 Physical Device 时，主要获取以下几类关键信息：</p>\n<ol>\n<li>\n<p>属性与标识：</p>\n<ul>\n<li>设备名称（如 “NVIDIA GeForce RTX 4080”）、供应商ID（Vendor ID)、设备ID</li>\n<li>API 版本、驱动程序版本</li>\n<li>设备类型：集成显卡（<code>INTEGRATED_GPU</code>）、独立显卡（<code>DISCRETE_GPU</code>）、虚拟GPU还是CPU</li>\n</ul>\n</li>\n<li>\n<p>功能特性</p>\n<ul>\n<li>图形管线特性：支持哪些着色器阶段、顶点/实现属性上限等</li>\n<li>计算能力：支持的计算着色器工作组大小等</li>\n<li>可选功能：API 核心规范只保证一个最低标准，所有的高级功能（如几何着色器，曲面细分，条件渲染，片段存储读写，光线追踪，网格着色器）都以特性或者拓展的形式给出，开发者需要显式查询并启用特定的功能</li>\n<li>纹理/缓冲区格式支持：哪些像素格式可用于渲染、采样或存储</li>\n</ul>\n</li>\n<li>\n<p>队列家族（Queue Families）</p>\n<ul>\n<li>队列家族揭示了 GPU 内部的并行执行架构，一个物理设备包含多个队列家族，每个家族专精于不同类型的工作负载（图形绘制，通用计算，异步数据传输，视频编解码）</li>\n<li>查询结果包括：\n<ul>\n<li>每个家族支持的操作类型（<code>GRAPHICS</code>, <code>COMPUTE</code>, <code>TRANSFER</code>, <code>SPARSE_BINDING</code>等）</li>\n<li>每个家族可用的队列数量，这决定了可并行提交的任务流数量</li>\n<li>每个家族是否支持与特定的显示表面进行呈现操作（Presentation）</li>\n</ul>\n</li>\n<li>正确的队列选择是并行渲染、计算与传输重叠的关键</li>\n</ul>\n</li>\n<li>\n<p>内存属性</p>\n<p>物理设备将内存组织为内存堆和内存类型：</p>\n<ul>\n<li>\n<p>内存堆：代表物理内存池（如独立的显存、共享的系统内存）。查询会提供每个堆的大小和标志</p>\n</li>\n<li>\n<p>内存类型：存在于堆中，是具有特定属性组合的逻辑划分，如：</p>\n<ul>\n<li>\n<p><code>DEVICE_LOCAL_BIT</code>：设备本地，访问速度最快，适合纹理和顶点缓冲区</p>\n</li>\n<li>\n<p><code>HOST_VISIBLE_BIT</code>：主机（CPU）可见，适合频繁更新的动态数据。</p>\n</li>\n<li>\n<p><code>HOST_COHERENT_BIT</code>：CPU与GPU缓存自动保持一致，简化操作但可能牺牲性能。</p>\n</li>\n<li>\n<p><code>HOST_CACHED_BIT</code>：主机端缓存，适合CPU随机读取的数据</p>\n</li>\n</ul>\n</li>\n<li>\n<p>根据资源访问模式选择正确的内存类型（如将常变数据放在<code>HOST_VISIBLE</code>内存中，将静态纹理放在<code>DEVICE_LOCAL</code>内存中）是应遵循的性能优化原则</p>\n</li>\n</ul>\n</li>\n<li>\n<p>格式支持</p>\n<p>查询特定纹理或缓冲区格式，对于给定的像素格式（如 <code>VK_FORMAT_R8G8B8A8_UNORM</code>）检查其支持的特性：</p>\n<ul>\n<li>\n<p><code>SAMPLED_IMAGE</code>：能否在着色器中采样。</p>\n</li>\n<li>\n<p><code>STORAGE_IMAGE</code>：能否在计算着色器中作为存储图像读写。</p>\n</li>\n<li>\n<p><code>COLOR_ATTACHMENT</code>：能否作为渲染目标。</p>\n</li>\n<li>\n<p><code>BLEND</code>：在作为渲染目标时是否支持混合</p>\n</li>\n</ul>\n</li>\n<li>\n<p>交换链支持</p>\n<p>此支持并非核心 API 的一部分，而是通过扩展实现。</p>\n<ul>\n<li>确认设备支持所需的窗口系统集成拓展（如 <code>VK_KHR_swapchain</code>）</li>\n<li>查询设备与特定窗口表面的兼容性，包括\n<ul>\n<li>支持的表面格式（像素格式，色彩空间）</li>\n<li>可用的呈现模式（立即模式、垂直同步 <code>FIFO</code>、无撕裂的 <code>MAILBOX</code> 等）</li>\n<li>表面能力（最小/最大图像数量、当前交换链图像分辨率范围等）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>高级架构特性</p>\n<ul>\n<li>多GPU支持：设备组（device groups）和链接设备（linked devices）的能力，用于协同多个GPU</li>\n<li>管线缓存：通过 <code>pipelineCacheUUID</code> 实现跨进程的管线缓存，加速管线创建</li>\n<li>稀疏内存：支持稀疏纹理和缓冲区，允许部分 residency 和动态映射，适用于流式加载大型纹理</li>\n<li>保守光栅化（Conservative Rasterization）、光栅顺序视图（Rasterization Order View）等高级渲染特性</li>\n<li>子组（Subgroup）操作：支持Wave操作，对计算着色器优化至关重要</li>\n<li>性能查询：支持时间戳和性能查询，用于性能分析</li>\n</ul>\n</li>\n</ol>\n<p> </p>\n<h1>3. Logical Device</h1>\n","path":"2025/11/30/现代图形-API/","permalink":"https://zweireverberate.space/2025/11/30/%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%BD%A2-API/","tags":[{"name":"Graphics","_id":"cmiltx92m000140cn5ew9erx3","slug":"Graphics","path":"tags/Graphics/","permalink":"https://zweireverberate.space/tags/Graphics/","length":1}],"categories":[],"prev":{"title":"数据结构与算法","date":"2025-12-27T13:39:50.000Z","summary":"数据结构与算法综述","slug":"数据结构与算法","published":true,"updated":"2026-01-03T13:56:10.367Z","_id":"cmjyd9nxc0000occnht9t22d2","layout":"post","photos":[],"excerpt":"","path":"2025/12/27/数据结构与算法/","permalink":"https://zweireverberate.space/2025/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","__post":true},"next":{"title":"C++ General","date":"2025-11-09T14:59:09.000Z","summary":"C++ 通义","slug":"C-General","published":true,"updated":"2025-11-23T08:30:45.270Z","_id":"cmhrudxky00005kcn5jz2f7fa","layout":"post","photos":[],"excerpt":"","path":"2025/11/09/C-General/","permalink":"https://zweireverberate.space/2025/11/09/C-General/","__post":true},"__post":true}