{"title":"C++ General","date":"2025-11-09T14:59:09.000Z","toc":true,"summary":"C++ 通义","source":"_posts/C-General.md","raw":"---\ntitle: C++ General\ndate: 2025-11-09 22:59:09\ntags: C++\ntoc: true\nsummary: \"C++ 通义\"\n---\n\n# 1. C++ 设计准则\n\n## 1. Philosophy\n\n### 1. 保持代码直观清晰\n\n```c++\nclass Date\n{\npublic:\n    Month month() const; // do\n    int month(); // don't\n}\n```\n\n在上述示例中，前者是更好的写法，它的返回值是类型明确的，并且本身具有 const 限定。\n\n&nbsp;\n\n```c++\nint index = -1;\nfor(int i = 0; i < v.size(); ++i)\n{\n    if(v[i] == val)\n    {\n        index = i;\n        break;\n    }\n} // bad\n\nauto it = std::find(std::begin(v), std::end(v), val); // better\n```\n\n使用 STL 能使代码更加清晰简洁，不易出错。有一句现代 C++ 谚语：如果你还在显式地使用循环，那么你就没有真正理解 STL 算法。\n\n&nbsp;\n\n### 2. 遵循 ISO Standard\n\n按照由国际标准化组织（ISO）制定并发布的《ISO/IEC 14882》C++ 标准来编写代码。\n\n这意味着尽量避免依赖各编译器厂商（如 GCC、MSVC、Clang）提供的额外语法或库扩展，以保证代码在不同环境下都能编译和运行。\n\n另外，需要注意 Undefined Behavior 和 Implementation‑Defined Behavior\n\n- Undefined Behavior\n\n  指 C++ 标准未明确规定行为规范的代码操作，允许编译器自由处理。程序可能崩溃、产生错误结果、或看似正常运行实则存在隐患。程序应避免任何 UB。\n\n   [*未定义行为完整列表*](https://parallel101.github.io/cppguidebook/undef/)\n\n- Implementation‑Defined Behavior\n\n  指 C++ 标准允许编译器或运行时环境自由选择具体实现方式，但要求该行为必须被明确文档化。虽然具有平台依赖性，但结果是可预测的，由特定编译器的实现文档保证。\n\n&nbsp;\n\n### 3. 注释应写明意图\n\n```c++\nfor(const auto& v : vec) {...} // (1)\n\nfor(auto& v : vec) {...} // (2)\n\nstd::for_each(std::execution::par, vec.begin(), vec.end(), [](auto& v) {...}); // (3)\n```\n\n上述示例中，(1) 与 (2) 的区别在于前者不会修改容器中的元素。\n\n(3) 是使用并行的方式对容器中的每个元素执行一个操作。但是需要注意的小规模数据可能因线程调度开销导致性能下降，这种写法更适用于大规模数据。\n\n总之，注释应阐明意图，指出应该做什么。\n\n&nbsp;\n\n### 4. 保证程序的静态类型安全\n\nC++ 是静态类型语言。即所有的变量或表达式的类型必须在编译时确定。静态类型安全要求编译器不仅知道其类型，还要能检测出类型相关的错误。C++ 并非完全类型安全，因此需要在编写代码时人工规避问题。\n\n以下是常见的类型安全的问题及规避方案：\n\n- 联合体（Union）\n\n  联合体允许不同类型共享同一内存空间，同一时间只能存储一个成员的值，可以达到节省内存的效果，`union` 的大小等于其最大成员的大小；\n\n  `union` 不记录当前活跃的成员，访问错误的成员会导致未定义行为。\n\n  ```c++\n  union Data \n  {\n      int i;\n      float f;\n  };\n  \n  Data data;\n  data.i = 10;\n  std::cout << data.f << std::endl; // 错误：此时通过 f 访问是未定义行为\n  ```\n\n  \n\n# 2. C++ 基础\n\n## 1. 平凡类型（Trivial Type）\n\nC++11 引入平凡类型的概念，用于描述“没有副作用的构造/析构/赋值等操作”的类型，一个类型是平凡类型当且仅当它满足以下所有条件：\n\n- 无用户定义的构造函数\n- 无用户定义的析构函数\n- 无用户定义的拷贝/移动构造函数\n- 无用户定义的拷贝/移动赋值操作符\n- 无虚函数，无虚基类\n- 所有非静态成员和基类都是平凡的\n\n可使用 `std::is_trivial` 进行判别。\n\nPOD 类型（Plain Old Data）相比于平凡类型是一个更严格、更古老的限制。在平凡类型的基础上还有标准布局（Standard Layout）的要求。\n\n标准布局类型满足以下条件：\n\n- 所有非静态成员具有相同的访问控制\n- 无虚函数，无虚基类\n- 没有引用类型的非静态数据成员\n- 所有非静态数据成员都是标准布局类型\n- 所有基类都是标准布局类型\n- 满足以下继承条件之一：\n  - 没有基类\n  - 只有一个基类且没有非静态数据成员\n  - 基类和派生类中不能同时有非静态数据成员\n\n可使用 `std::is_standard_layout_v` 判别是否是标准布局类型。\n\nPOD 类型也有 `std::is_pod` 这样的判断方法，但是该方法已经在 C++20 中被移除，不推荐使用。可通过 `std::is_standard_layout_v` 和 `std::is_trivial` 的组合来达到相同的目的。即：\n\n>POD = Trivial && Standard Layout\n\n```c++\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\nvoid checkTypeProperties() \n{\n    std::cout << \"Type: \" << typeid(T).name() << \"\\n\";\n    std::cout << \"Is trivial: \" << std::is_trivial_v<T> << \"\\n\";\n    std::cout << \"Is standard layout: \" << std::is_standard_layout_v<T> << \"\\n\";\n    std::cout << \"Is POD: \" << std::is_pod_v<T> << \"\\n\";\n    std::cout << \"---\\n\";\n}\n\n// POD类型\nstruct POD_Example \n{        \n    int a;\n    char b;\n};\n\n// 平凡但非POD\nstruct TrivialNonPOD1 \n{     \npublic:\n    int public_member;\nprivate:\n    int private_member;\n};\n\n// 继承破坏标准布局\nstruct TrivialNonPOD2 : POD_Example \n{  \n    int additional_member;\n};\n\nint main() \n{\n    checkTypeProperties<POD_Example>();\n    checkTypeProperties<TrivialNonPOD1>();\n    checkTypeProperties<TrivialNonPOD2>();\n    return 0;\n}\n```\n\n\n\n**应用场景**\n\n- 平凡类型\n\n  其核心特性在于可以使用 `memcpy` 等低级内存操作进行复制，而不需要逐个调用拷贝构造函数，在需要高效移动和复制时很有用。\n  \n  ```c++\n  // 高效内存复制\n  template<typename T>\n  void trivial_copy(const T* src, T* dest, size_t count) \n  {\n      static_assert(std::is_trivial_v<T>, \n      \"Type must be trivial for memcpy operations\");\n      std::memcpy(dest, src, count * sizeof(T));\n  }\n  \n  // 序列化/反序列化\n  struct TrivialData \n  {\n      int id;\n      double value;\n      char name[32];\n  };\n  void serialize_trivial(const TrivialData& data, char* buffer) \n  {\n      // 安全地直接复制内存\n      std::memcpy(buffer, &data, sizeof(TrivialData));\n  }\n  \n  // 对象池和内存管理\n  template<typename T>\n  class ObjectPool \n  {\n      static_assert(std::is_trivial_v<T>, \"ObjectPool requires trivial types for efficient reuse\");\n      std::vector<T> pool;\n  public:\n      T* allocate() \n      {\n          // 可以安全地重用内存而不调用析构函数\n          return &pool.emplace_back();\n      }\n  };\n  ```\n  \n- 标准布局类型\n\n  其核心特性是确定性的内存布局，并与 C 语言兼容\n\n  ```c++\n  // 与C语言互操作\n  extern \"C\" \n  {\n      struct CStruct \n      {\n          int x;\n          double y;\n      };\n      void process_c_struct(CStruct* data);\n  }\n  struct CompatibleCppStruct \n  {\n      int x;\n      double y;\n  }; // 标准布局，可以与C结构体安全互操作\n  static_assert(std::is_standard_layout_v<CompatibleCppStruct>);\n  \n  // 硬件寄存器映射\n  struct DeviceRegisterMap \n  {\n      volatile uint32_t control;\n      volatile uint32_t status;\n      volatile uint32_t data;\n  }; // 标准布局确保成员顺序与硬件寄存器一致\n  \n  // 网络协议数据包\n  #pragma pack(push, 1)\n  struct NetworkPacket \n  {\n      uint16_t header;\n      uint32_t sequence;\n      uint8_t payload[1024];\n      uint16_t checksum;\n  }; // 标准布局 + 打包确保精确的内存布局\n  #pragma pack(pop)\n  \n  // 通过偏移量访问成员\n  template<typename T, typename M>\n  size_t member_offset(M T::*member) \n  {\n      static_assert(std::is_standard_layout_v<T>);\n      return reinterpret_cast<size_t>(&(reinterpret_cast<T*>(0)->*member));\n  } // 只有标准布局类型才有确定的成员偏移量\n  ```\n\n- POD 类型\n\n  同时拥有以上两种类型的特性，是二者的交集。但现代 C++ 编码中应尽量避免使用这个概念。\n\n----\n\n**Reference**\n\n- [*C++ Core Guidelines Explained: Best Practices for Modern C++*](https://www.google.com/books/edition/C++_Core_Guidelines_Explained/ptnPEAAAQBAJ?hl=en&gbpv=0)\n- [*现代 C++ 教程*](https://www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.788.comment.all.click&vd_source=aec47f6b52af3774b903cb0d25607f6c)\n- [*小彭大典*](https://parallel101.github.io/cppguidebook/)","slug":"C-General","published":true,"updated":"2025-11-10T16:00:37.221Z","_id":"cmhrudxky00005kcn5jz2f7fa","comments":true,"layout":"post","photos":[],"html":"<h1>1. C++ 设计准则</h1>\n<h2 id=\"1-Philosophy\">1. Philosophy</h2>\n<h3 id=\"1-保持代码直观清晰\">1. 保持代码直观清晰</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Month <span class=\"title\">month</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>; <span class=\"comment\">// do</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">month</span><span class=\"params\">()</span></span>; <span class=\"comment\">// don&#x27;t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，前者是更好的写法，它的返回值是类型明确的，并且本身具有 const 限定。</p>\n<p> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; v.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(v[i] == val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        index = i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// bad</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find</span>(std::<span class=\"built_in\">begin</span>(v), std::<span class=\"built_in\">end</span>(v), val); <span class=\"comment\">// better</span></span><br></pre></td></tr></table></figure>\n<p>使用 STL 能使代码更加清晰简洁，不易出错。有一句现代 C++ 谚语：如果你还在显式地使用循环，那么你就没有真正理解 STL 算法。</p>\n<p> </p>\n<h3 id=\"2-遵循-ISO-Standard\">2. 遵循 ISO Standard</h3>\n<p>按照由国际标准化组织（ISO）制定并发布的《ISO/IEC 14882》C++ 标准来编写代码。</p>\n<p>这意味着尽量避免依赖各编译器厂商（如 GCC、MSVC、Clang）提供的额外语法或库扩展，以保证代码在不同环境下都能编译和运行。</p>\n<p>另外，需要注意 Undefined Behavior 和 Implementation‑Defined Behavior</p>\n<ul>\n<li>\n<p>Undefined Behavior</p>\n<p>指 C++ 标准未明确规定行为规范的代码操作，允许编译器自由处理。程序可能崩溃、产生错误结果、或看似正常运行实则存在隐患。程序应避免任何 UB。</p>\n<p><a href=\"https://parallel101.github.io/cppguidebook/undef/\"><em>未定义行为完整列表</em></a></p>\n</li>\n<li>\n<p>Implementation‑Defined Behavior</p>\n<p>指 C++ 标准允许编译器或运行时环境自由选择具体实现方式，但要求该行为必须被明确文档化。虽然具有平台依赖性，但结果是可预测的，由特定编译器的实现文档保证。</p>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"3-注释应写明意图\">3. 注释应写明意图</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; v : vec) &#123;...&#125; <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; v : vec) &#123;...&#125; <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::for_each(std::execution::par, vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">auto</span>&amp; v) &#123;...&#125;); <span class=\"comment\">// (3)</span></span><br></pre></td></tr></table></figure>\n<p>上述示例中，(1) 与 (2) 的区别在于前者不会修改容器中的元素。</p>\n<p>(3) 是使用并行的方式对容器中的每个元素执行一个操作。但是需要注意的小规模数据可能因线程调度开销导致性能下降，这种写法更适用于大规模数据。</p>\n<p>总之，注释应阐明意图，指出应该做什么。</p>\n<p> </p>\n<h3 id=\"4-保证程序的静态类型安全\">4. 保证程序的静态类型安全</h3>\n<p>C++ 是静态类型语言。即所有的变量或表达式的类型必须在编译时确定。静态类型安全要求编译器不仅知道其类型，还要能检测出类型相关的错误。C++ 并非完全类型安全，因此需要在编写代码时人工规避问题。</p>\n<p>以下是常见的类型安全的问题及规避方案：</p>\n<ul>\n<li>\n<p>联合体（Union）</p>\n<p>联合体允许不同类型共享同一内存空间，同一时间只能存储一个成员的值，可以达到节省内存的效果，<code>union</code> 的大小等于其最大成员的大小；</p>\n<p><code>union</code> 不记录当前活跃的成员，访问错误的成员会导致未定义行为。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">Data</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">float</span> f;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Data data;</span><br><span class=\"line\">data.i = <span class=\"number\">10</span>;</span><br><span class=\"line\">std::cout &lt;&lt; data.f &lt;&lt; std::endl; <span class=\"comment\">// 错误：此时通过 f 访问是未定义行为</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1>2. C++ 基础</h1>\n<h2 id=\"1-平凡类型（Trivial-Type）\">1. 平凡类型（Trivial Type）</h2>\n<p>C++11 引入平凡类型的概念，用于描述“没有副作用的构造/析构/赋值等操作”的类型，一个类型是平凡类型当且仅当它满足以下所有条件：</p>\n<ul>\n<li>无用户定义的构造函数</li>\n<li>无用户定义的析构函数</li>\n<li>无用户定义的拷贝/移动构造函数</li>\n<li>无用户定义的拷贝/移动赋值操作符</li>\n<li>无虚函数，无虚基类</li>\n<li>所有非静态成员和基类都是平凡的</li>\n</ul>\n<p>可使用 <code>std::is_trivial</code> 进行判别。</p>\n<p>POD 类型（Plain Old Data）相比于平凡类型是一个更严格、更古老的限制。在平凡类型的基础上还有标准布局（Standard Layout）的要求。</p>\n<p>标准布局类型满足以下条件：</p>\n<ul>\n<li>所有非静态成员具有相同的访问控制</li>\n<li>无虚函数，无虚基类</li>\n<li>没有引用类型的非静态数据成员</li>\n<li>所有非静态数据成员都是标准布局类型</li>\n<li>所有基类都是标准布局类型</li>\n<li>满足以下继承条件之一：\n<ul>\n<li>没有基类</li>\n<li>只有一个基类且没有非静态数据成员</li>\n<li>基类和派生类中不能同时有非静态数据成员</li>\n</ul>\n</li>\n</ul>\n<p>可使用 <code>std::is_standard_layout_v</code> 判别是否是标准布局类型。</p>\n<p>POD 类型也有 <code>std::is_pod</code> 这样的判断方法，但是该方法已经在 C++20 中被移除，不推荐使用。可通过 <code>std::is_standard_layout_v</code> 和 <code>std::is_trivial</code> 的组合来达到相同的目的。即：</p>\n<blockquote>\n<p>POD = Trivial &amp;&amp; Standard Layout</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checkTypeProperties</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Type: &quot;</span> &lt;&lt; <span class=\"built_in\">typeid</span>(T).<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is trivial: &quot;</span> &lt;&lt; std::is_trivial_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is standard layout: &quot;</span> &lt;&lt; std::is_standard_layout_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is POD: &quot;</span> &lt;&lt; std::is_pod_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;---\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POD类型</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">POD_Example</span> </span><br><span class=\"line\">&#123;        </span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">char</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 平凡但非POD</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialNonPOD1</span> </span><br><span class=\"line\">&#123;     </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> public_member;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> private_member;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承破坏标准布局</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialNonPOD2</span> : POD_Example </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"type\">int</span> additional_member;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;POD_Example&gt;();</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;TrivialNonPOD1&gt;();</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;TrivialNonPOD2&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>\n<p>平凡类型</p>\n<p>其核心特性在于可以使用 <code>memcpy</code> 等低级内存操作进行复制，而不需要逐个调用拷贝构造函数，在需要高效移动和复制时很有用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 高效内存复制</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">trivial_copy</span><span class=\"params\">(<span class=\"type\">const</span> T* src, T* dest, <span class=\"type\">size_t</span> count)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_trivial_v&lt;T&gt;, </span><br><span class=\"line\">    <span class=\"string\">&quot;Type must be trivial for memcpy operations&quot;</span>);</span><br><span class=\"line\">    std::<span class=\"built_in\">memcpy</span>(dest, src, count * <span class=\"built_in\">sizeof</span>(T));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 序列化/反序列化</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialData</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">double</span> value;</span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">32</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">serialize_trivial</span><span class=\"params\">(<span class=\"type\">const</span> TrivialData&amp; data, <span class=\"type\">char</span>* buffer)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 安全地直接复制内存</span></span><br><span class=\"line\">    std::<span class=\"built_in\">memcpy</span>(buffer, &amp;data, <span class=\"built_in\">sizeof</span>(TrivialData));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象池和内存管理</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_trivial_v&lt;T&gt;, <span class=\"string\">&quot;ObjectPool requires trivial types for efficient reuse&quot;</span>);</span><br><span class=\"line\">    std::vector&lt;T&gt; pool;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">T* <span class=\"title\">allocate</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以安全地重用内存而不调用析构函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;pool.<span class=\"built_in\">emplace_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>标准布局类型</p>\n<p>其核心特性是确定性的内存布局，并与 C 语言兼容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 与C语言互操作</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">CStruct</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        <span class=\"type\">double</span> y;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process_c_struct</span><span class=\"params\">(CStruct* data)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CompatibleCppStruct</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">double</span> y;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局，可以与C结构体安全互操作</span></span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(std::is_standard_layout_v&lt;CompatibleCppStruct&gt;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 硬件寄存器映射</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">DeviceRegisterMap</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> control;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> status;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> data;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局确保成员顺序与硬件寄存器一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 网络协议数据包</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(push, 1)</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">NetworkPacket</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> header;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> sequence;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> payload[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> checksum;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局 + 打包确保精确的内存布局</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(pop)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过偏移量访问成员</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> M&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">member_offset</span><span class=\"params\">(M T::*member)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_standard_layout_v&lt;T&gt;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(&amp;(<span class=\"built_in\">reinterpret_cast</span>&lt;T*&gt;(<span class=\"number\">0</span>)-&gt;*member));</span><br><span class=\"line\">&#125; <span class=\"comment\">// 只有标准布局类型才有确定的成员偏移量</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>POD 类型</p>\n<p>同时拥有以上两种类型的特性，是二者的交集。但现代 C++ 编码中应尽量避免使用这个概念。</p>\n</li>\n</ul>\n<hr>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://www.google.com/books/edition/C++_Core_Guidelines_Explained/ptnPEAAAQBAJ?hl=en&amp;gbpv=0\"><em>C++ Core Guidelines Explained: Best Practices for Modern C++</em></a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.788.comment.all.click&amp;vd_source=aec47f6b52af3774b903cb0d25607f6c\"><em>现代 C++ 教程</em></a></li>\n<li><a href=\"https://parallel101.github.io/cppguidebook/\"><em>小彭大典</em></a></li>\n</ul>\n","excerpt":"","more":"<h1>1. C++ 设计准则</h1>\n<h2 id=\"1-Philosophy\">1. Philosophy</h2>\n<h3 id=\"1-保持代码直观清晰\">1. 保持代码直观清晰</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Month <span class=\"title\">month</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>; <span class=\"comment\">// do</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">month</span><span class=\"params\">()</span></span>; <span class=\"comment\">// don&#x27;t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，前者是更好的写法，它的返回值是类型明确的，并且本身具有 const 限定。</p>\n<p> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; v.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(v[i] == val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        index = i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// bad</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find</span>(std::<span class=\"built_in\">begin</span>(v), std::<span class=\"built_in\">end</span>(v), val); <span class=\"comment\">// better</span></span><br></pre></td></tr></table></figure>\n<p>使用 STL 能使代码更加清晰简洁，不易出错。有一句现代 C++ 谚语：如果你还在显式地使用循环，那么你就没有真正理解 STL 算法。</p>\n<p> </p>\n<h3 id=\"2-遵循-ISO-Standard\">2. 遵循 ISO Standard</h3>\n<p>按照由国际标准化组织（ISO）制定并发布的《ISO/IEC 14882》C++ 标准来编写代码。</p>\n<p>这意味着尽量避免依赖各编译器厂商（如 GCC、MSVC、Clang）提供的额外语法或库扩展，以保证代码在不同环境下都能编译和运行。</p>\n<p>另外，需要注意 Undefined Behavior 和 Implementation‑Defined Behavior</p>\n<ul>\n<li>\n<p>Undefined Behavior</p>\n<p>指 C++ 标准未明确规定行为规范的代码操作，允许编译器自由处理。程序可能崩溃、产生错误结果、或看似正常运行实则存在隐患。程序应避免任何 UB。</p>\n<p><a href=\"https://parallel101.github.io/cppguidebook/undef/\"><em>未定义行为完整列表</em></a></p>\n</li>\n<li>\n<p>Implementation‑Defined Behavior</p>\n<p>指 C++ 标准允许编译器或运行时环境自由选择具体实现方式，但要求该行为必须被明确文档化。虽然具有平台依赖性，但结果是可预测的，由特定编译器的实现文档保证。</p>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"3-注释应写明意图\">3. 注释应写明意图</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; v : vec) &#123;...&#125; <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; v : vec) &#123;...&#125; <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::for_each(std::execution::par, vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">auto</span>&amp; v) &#123;...&#125;); <span class=\"comment\">// (3)</span></span><br></pre></td></tr></table></figure>\n<p>上述示例中，(1) 与 (2) 的区别在于前者不会修改容器中的元素。</p>\n<p>(3) 是使用并行的方式对容器中的每个元素执行一个操作。但是需要注意的小规模数据可能因线程调度开销导致性能下降，这种写法更适用于大规模数据。</p>\n<p>总之，注释应阐明意图，指出应该做什么。</p>\n<p> </p>\n<h3 id=\"4-保证程序的静态类型安全\">4. 保证程序的静态类型安全</h3>\n<p>C++ 是静态类型语言。即所有的变量或表达式的类型必须在编译时确定。静态类型安全要求编译器不仅知道其类型，还要能检测出类型相关的错误。C++ 并非完全类型安全，因此需要在编写代码时人工规避问题。</p>\n<p>以下是常见的类型安全的问题及规避方案：</p>\n<ul>\n<li>\n<p>联合体（Union）</p>\n<p>联合体允许不同类型共享同一内存空间，同一时间只能存储一个成员的值，可以达到节省内存的效果，<code>union</code> 的大小等于其最大成员的大小；</p>\n<p><code>union</code> 不记录当前活跃的成员，访问错误的成员会导致未定义行为。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">Data</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">float</span> f;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Data data;</span><br><span class=\"line\">data.i = <span class=\"number\">10</span>;</span><br><span class=\"line\">std::cout &lt;&lt; data.f &lt;&lt; std::endl; <span class=\"comment\">// 错误：此时通过 f 访问是未定义行为</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1>2. C++ 基础</h1>\n<h2 id=\"1-平凡类型（Trivial-Type）\">1. 平凡类型（Trivial Type）</h2>\n<p>C++11 引入平凡类型的概念，用于描述“没有副作用的构造/析构/赋值等操作”的类型，一个类型是平凡类型当且仅当它满足以下所有条件：</p>\n<ul>\n<li>无用户定义的构造函数</li>\n<li>无用户定义的析构函数</li>\n<li>无用户定义的拷贝/移动构造函数</li>\n<li>无用户定义的拷贝/移动赋值操作符</li>\n<li>无虚函数，无虚基类</li>\n<li>所有非静态成员和基类都是平凡的</li>\n</ul>\n<p>可使用 <code>std::is_trivial</code> 进行判别。</p>\n<p>POD 类型（Plain Old Data）相比于平凡类型是一个更严格、更古老的限制。在平凡类型的基础上还有标准布局（Standard Layout）的要求。</p>\n<p>标准布局类型满足以下条件：</p>\n<ul>\n<li>所有非静态成员具有相同的访问控制</li>\n<li>无虚函数，无虚基类</li>\n<li>没有引用类型的非静态数据成员</li>\n<li>所有非静态数据成员都是标准布局类型</li>\n<li>所有基类都是标准布局类型</li>\n<li>满足以下继承条件之一：\n<ul>\n<li>没有基类</li>\n<li>只有一个基类且没有非静态数据成员</li>\n<li>基类和派生类中不能同时有非静态数据成员</li>\n</ul>\n</li>\n</ul>\n<p>可使用 <code>std::is_standard_layout_v</code> 判别是否是标准布局类型。</p>\n<p>POD 类型也有 <code>std::is_pod</code> 这样的判断方法，但是该方法已经在 C++20 中被移除，不推荐使用。可通过 <code>std::is_standard_layout_v</code> 和 <code>std::is_trivial</code> 的组合来达到相同的目的。即：</p>\n<blockquote>\n<p>POD = Trivial &amp;&amp; Standard Layout</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checkTypeProperties</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Type: &quot;</span> &lt;&lt; <span class=\"built_in\">typeid</span>(T).<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is trivial: &quot;</span> &lt;&lt; std::is_trivial_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is standard layout: &quot;</span> &lt;&lt; std::is_standard_layout_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is POD: &quot;</span> &lt;&lt; std::is_pod_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;---\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POD类型</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">POD_Example</span> </span><br><span class=\"line\">&#123;        </span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">char</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 平凡但非POD</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialNonPOD1</span> </span><br><span class=\"line\">&#123;     </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> public_member;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> private_member;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承破坏标准布局</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialNonPOD2</span> : POD_Example </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"type\">int</span> additional_member;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;POD_Example&gt;();</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;TrivialNonPOD1&gt;();</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;TrivialNonPOD2&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>\n<p>平凡类型</p>\n<p>其核心特性在于可以使用 <code>memcpy</code> 等低级内存操作进行复制，而不需要逐个调用拷贝构造函数，在需要高效移动和复制时很有用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 高效内存复制</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">trivial_copy</span><span class=\"params\">(<span class=\"type\">const</span> T* src, T* dest, <span class=\"type\">size_t</span> count)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_trivial_v&lt;T&gt;, </span><br><span class=\"line\">    <span class=\"string\">&quot;Type must be trivial for memcpy operations&quot;</span>);</span><br><span class=\"line\">    std::<span class=\"built_in\">memcpy</span>(dest, src, count * <span class=\"built_in\">sizeof</span>(T));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 序列化/反序列化</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialData</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">double</span> value;</span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">32</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">serialize_trivial</span><span class=\"params\">(<span class=\"type\">const</span> TrivialData&amp; data, <span class=\"type\">char</span>* buffer)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 安全地直接复制内存</span></span><br><span class=\"line\">    std::<span class=\"built_in\">memcpy</span>(buffer, &amp;data, <span class=\"built_in\">sizeof</span>(TrivialData));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象池和内存管理</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_trivial_v&lt;T&gt;, <span class=\"string\">&quot;ObjectPool requires trivial types for efficient reuse&quot;</span>);</span><br><span class=\"line\">    std::vector&lt;T&gt; pool;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">T* <span class=\"title\">allocate</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以安全地重用内存而不调用析构函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;pool.<span class=\"built_in\">emplace_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>标准布局类型</p>\n<p>其核心特性是确定性的内存布局，并与 C 语言兼容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 与C语言互操作</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">CStruct</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        <span class=\"type\">double</span> y;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process_c_struct</span><span class=\"params\">(CStruct* data)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CompatibleCppStruct</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">double</span> y;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局，可以与C结构体安全互操作</span></span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(std::is_standard_layout_v&lt;CompatibleCppStruct&gt;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 硬件寄存器映射</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">DeviceRegisterMap</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> control;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> status;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> data;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局确保成员顺序与硬件寄存器一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 网络协议数据包</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(push, 1)</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">NetworkPacket</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> header;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> sequence;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> payload[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> checksum;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局 + 打包确保精确的内存布局</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(pop)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过偏移量访问成员</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> M&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">member_offset</span><span class=\"params\">(M T::*member)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_standard_layout_v&lt;T&gt;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(&amp;(<span class=\"built_in\">reinterpret_cast</span>&lt;T*&gt;(<span class=\"number\">0</span>)-&gt;*member));</span><br><span class=\"line\">&#125; <span class=\"comment\">// 只有标准布局类型才有确定的成员偏移量</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>POD 类型</p>\n<p>同时拥有以上两种类型的特性，是二者的交集。但现代 C++ 编码中应尽量避免使用这个概念。</p>\n</li>\n</ul>\n<hr>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://www.google.com/books/edition/C++_Core_Guidelines_Explained/ptnPEAAAQBAJ?hl=en&amp;gbpv=0\"><em>C++ Core Guidelines Explained: Best Practices for Modern C++</em></a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.788.comment.all.click&amp;vd_source=aec47f6b52af3774b903cb0d25607f6c\"><em>现代 C++ 教程</em></a></li>\n<li><a href=\"https://parallel101.github.io/cppguidebook/\"><em>小彭大典</em></a></li>\n</ul>\n","path":"2025/11/09/C-General/","permalink":"https://zweireverberate.space/2025/11/09/C-General/","tags":[{"name":"C++","_id":"cmhrudxl400015kcn8x15hevj","slug":"C","path":"tags/C/","permalink":"https://zweireverberate.space/tags/C/","length":1}],"categories":[],"prev":{"title":"素影微行","date":"2989-06-04T06:36:24.000Z","summary":"随笔","slug":"素影微行","published":true,"updated":"2025-07-14T15:13:50.317Z","_id":"cmefcsga500017gcn3f043goh","layout":"post","photos":[],"excerpt":"","path":"2989/06/04/素影微行/","permalink":"https://zweireverberate.space/2989/06/04/%E7%B4%A0%E5%BD%B1%E5%BE%AE%E8%A1%8C/","__post":true},"next":{"title":"Coding Problems","date":"2025-10-26T12:05:21.000Z","summary":"算法练习题","slug":"Coding-Problems","published":true,"updated":"2025-11-02T08:11:00.332Z","_id":"cmh7o11j60000r4cn5skl1af9","layout":"post","photos":[],"excerpt":"","path":"2025/10/26/Coding-Problems/","permalink":"https://zweireverberate.space/2025/10/26/Coding-Problems/","__post":true},"__post":true}