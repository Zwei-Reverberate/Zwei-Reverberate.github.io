{"title":"C++ General","date":"2025-11-09T14:59:09.000Z","toc":true,"summary":"C++ 通义","source":"_posts/C-General.md","raw":"---\ntitle: C++ General\ndate: 2025-11-09 22:59:09\ntags: C++\ntoc: true\nsummary: \"C++ 通义\"\n---\n\n# 1. C++ 设计准则\n\n## 1. Philosophy\n\n### 1. 保持代码直观清晰\n\n```c++\nclass Date\n{\npublic:\n    Month month() const; // do\n    int month(); // don't\n}\n```\n\n在上述示例中，前者是更好的写法，它的返回值是类型明确的，并且本身具有 const 限定。\n\n&nbsp;\n\n```c++\nint index = -1;\nfor(int i = 0; i < v.size(); ++i)\n{\n    if(v[i] == val)\n    {\n        index = i;\n        break;\n    }\n} // bad\n\nauto it = std::find(std::begin(v), std::end(v), val); // better\n```\n\n使用 STL 能使代码更加清晰简洁，不易出错。有一句现代 C++ 谚语：如果你还在显式地使用循环，那么你就没有真正理解 STL 算法。\n\n&nbsp;\n\n### 2. 遵循 ISO Standard\n\n按照由国际标准化组织（ISO）制定并发布的《ISO/IEC 14882》C++ 标准来编写代码。\n\n这意味着尽量避免依赖各编译器厂商（如 GCC、MSVC、Clang）提供的额外语法或库扩展，以保证代码在不同环境下都能编译和运行。\n\n另外，需要注意 Undefined Behavior 和 Implementation‑Defined Behavior\n\n- Undefined Behavior\n\n  指 C++ 标准未明确规定行为规范的代码操作，允许编译器自由处理。程序可能崩溃、产生错误结果、或看似正常运行实则存在隐患。程序应避免任何 UB。\n\n   [*未定义行为完整列表*](https://parallel101.github.io/cppguidebook/undef/)\n\n- Implementation‑Defined Behavior\n\n  指 C++ 标准允许编译器或运行时环境自由选择具体实现方式，但要求该行为必须被明确文档化。虽然具有平台依赖性，但结果是可预测的，由特定编译器的实现文档保证。\n\n&nbsp;\n\n### 3. 注释应写明意图\n\n```c++\nfor(const auto& v : vec) {...} // (1)\n\nfor(auto& v : vec) {...} // (2)\n\nstd::for_each(std::execution::par, vec.begin(), vec.end(), [](auto& v) {...}); // (3)\n```\n\n上述示例中，(1) 与 (2) 的区别在于前者不会修改容器中的元素。\n\n(3) 是使用并行的方式对容器中的每个元素执行一个操作。但是需要注意的小规模数据可能因线程调度开销导致性能下降，这种写法更适用于大规模数据。\n\n总之，注释应阐明意图，指出应该做什么。\n\n&nbsp;\n\n### 4. 保证程序的静态类型安全\n\nC++ 是静态类型语言。即所有的变量或表达式的类型必须在编译时确定。静态类型安全要求编译器不仅知道其类型，还要能检测出类型相关的错误。C++ 并非完全类型安全，因此需要在编写代码时人工规避问题。\n\n以下是常见的类型安全的问题及规避方案：\n\n- 联合体（Union）\n\n  联合体允许不同类型共享同一内存空间，同一时间只能存储一个成员的值，可以达到节省内存的效果，`union` 的大小等于其最大成员的大小；\n\n  `union` 不记录当前活跃的成员，访问错误的成员会导致未定义行为。\n\n  ```c++\n  union Data \n  {\n      int i;\n      float f;\n  };\n  \n  Data data;\n  data.i = 10;\n  std::cout << data.f << std::endl; // 错误：此时通过 f 访问是未定义行为\n  ```\n\n  在 C++11 之前，`union` 仅支持平凡类型。C++11 之后可以包含非平凡类型，但有严格限制。必须提供自定义构造函数，因为 `union` 的默认构造函数是 `delete` 状态。\n  \n  ```c++\n  #include <string>\n  \n  union MyUnion \n  {\n      int i;\n      std::string s;  // 非平凡类型\n      // 编译器不会生成默认构造函数\n      // MyUnion() = delete;\n  };\n  \n  int main() \n  {\n      // MyUnion u;  // 错误,默认构造函数被删除\n      return 0;\n  }\n  ```\n  \n  必须显式管理生命周期和追踪活跃成员，比如析构时需要识别出活跃成员，否则析构出错会有未定义行为。\n  \n  C++17 引入了 `std::variant`，它是一个类型安全的联合体。可以方便地存储非平凡类型，并且自动管理存储资源的生命周期，是 `union` 的上位替代。\n  \n  ```c++\n  std::variant<int, std::string> v = \"hello\";\n  \n  // 需要知道类型进行访问\n  std::cout << std::get<std::string>(v) << std::endl;\n  \n  // 类型安全的访问方式\n  if (auto* str = std::get_if<std::string>(&v)) \n  {\n      std::cout << *str << std::endl;\n  }\n  ```\n\n- 类型转换\n\n  显式类型转换（如 `static_cast`、`dynamic_cast`、`reinterpret_cast`、`const_cast`）可能引发错误或未定义行为\n\n  >`dynamic_cast` 相对安全，有运行时类型检查。对于指针类型，转换失败会返回空指针；对于引用类型，转换失败会抛出 `std::bad_cast` 异常。\n\n  而基于模板的泛型代码减少了对类型转换的需求，从某种程度上可以减少此类错误。\n\n- 数组退化\n\n  C 风格数组在传递给函数时，会退化为指向其首元素的指针，丢失数组大小信息。\n\n  ```c++\n  void processArray(int arr[]) \n  {\n      // 这里 arr 实际上是指针，不是数组\n      // 输出指针大小(8/4字节)，无法获取原始数组大小\n      std::cout << \"Size in function: \" << sizeof(arr) << std::endl; \t\n  }\n  ```\n  \n  C++20 提供的 `std::span` 是一个轻量级的视图，包含指针和大小信息，提供安全的数组访问，可以解决这个问题。\n  \n  ```c++\n  #include <iostream>\n  #include <span>\n  #include <vector>\n  #include <array>\n  \n  // 使用 std::span 接收数组，自动保持大小信息\n  void processWithSpan(std::span<int> arr) \n  {\n      std::cout << \"Span size: \" << arr.size() << std::endl;\n      std::cout << \"Span data: \";\n  \n      for (int value : arr) \n      {\n          std::cout << value << \" \";\n      }\n      std::cout << std::endl;\n  \n      // 安全的索引访问\n      for (size_t i = 0; i < arr.size(); i++) \n      {\n          std::cout << arr[i] << \" \";\n      }\n      std::cout << std::endl;\n  \n      // 子视图，同样安全\n      if (arr.size() >= 3) \n      {\n          auto subspan = arr.subspan(1, 2); // 从索引1开始，取2个元素\n          std::cout << \"Subspan: \";\n          for (int val : subspan) \n          {\n              std::cout << val << \" \";\n          }\n          std::cout << std::endl;\n      }\n  }\n  \n  int main() \n  {\n      // 1. C 风格数组，自动推导大小\n      int cArray[] = { 1, 2, 3, 4, 5 };\n      processWithSpan(cArray); \n  \n      // 2. std::array\n      std::array<int, 4> stdArray = { 6, 7, 8, 9 };\n      processWithSpan(stdArray);\n  \n      // 3. std::vector\n      std::vector<int> vec = { 10, 11, 12, 13, 14 };\n      processWithSpan(vec);\n  \n      // 4. 动态数组，需要显式提供大小\n      int* dynamicArray = new int[3] {15, 16, 17};\n      processWithSpan(std::span<int>(dynamicArray, 3)); \n      delete[] dynamicArray;\n  \n      return 0;\n  }\n  ```\n  \n  需要注意的是，动态数组的大小在运行时确定，编译期无法推导，所以需要显式提供大小。而 `std::vector` 因为它本身是包含 size 信息的完整类型，所以即使其 size 是在运行期确定的，也无需向 `std::span` 显式提供大小。\n  \n- 窄化转换\n\n  隐式转换可能导致数据丢失（如 `double` → `int` 截断小数）\n\n  使用 `{}` 初始化（列表初始化）时，编译器会强制检查并拒绝窄化转换，帮助在编译期捕获此类错误。\n\n&nbsp;\n\n### 5. 优先编译期检查而非运行期检查\n\n所有能够在编译期进行的检查，都应当置于编译期完成。C++11 引入编译期断言 `static_assert` ，它接受一个常量表达式，在编译期验证条件，对条件不满足或者运行期才能确定的表达式产生编译错误。\n\n此外，类型特征库（type-traits library）允许开发者构建强大的条件检查：例如`static_assert(std::is_integral<T>::value)`。\n\n&nbsp;\n\n### 6. 无法在编译期检查的内容，应当能够在运行期进行检查\n\n借助 `dynamic_cast`，我们能够安全地在继承层次结构中向上、向下及横向转换类的指针和引用。如果转换失败，对于指针会返回 `nullptr`，对于引用则会抛出 `std::bad_cast` 异常\n\n`dynamic_cast` 依赖于运行时类型信息（Run-Time Type Information, RTTI），而 RTTI 只对多态类型（即包含虚函数的类）可用。\n\n>编译器在 `vtable` 中嵌入 `type_info` 对象，非多态类类型没有 `vtable`，因此没有存储类型信息的地方，`dynamic_cast` 通过查询对象的 `type_info` 来验证转换的合法性\n\n&nbsp;&nbsp;\n\n### 7. 尽早捕获运行期错误\n\n可采用多种对策消除运行时错误。比如检查指针、数组范围、类型转换等，避免错误的传播和扩散。\n\n&nbsp;\n\n### 8. 不要泄露任何资源\n\n资源不仅指内存，还包括系统资源，如文件句柄、网络套接字、数据库连接、图形界面句柄、互斥锁等\n\n任何资源如果只申请不释放，都会随着程序的运行而不断累积。对于需要长时间运行的服务端程序或后台进程，即使是微小的泄露，最终也可能耗尽系统资源，导致程序崩溃或系统变得不稳定。\n\n处理资源的惯用方法是 RAII (Resource Acquisition Is Initialization)：\n\n- 将资源的生命周期与一个对象的生命周期绑定\n- 在对象的构造函数中获取资源\n- 在对象的析构函数中释放资源\n- C++保证，当对象离开其作用域时（无论是正常离开，还是因为异常而离开），其析构函数一定会被自动调用，无需手动干预\n\n>成员对象的析构函数在持有它的类析构时会自动调用，但它持有的资源是否需要手动释放，取决于该成员类型本身的实现\n\nRAII 应用示例：\n\n- 锁：如 `std::lock_guard` 或 `std::unique_lock`。在构造时锁定互斥量，在析构时自动解锁。这防止了因忘记解锁而导致的死锁\n- 智能指针：如 `std::unique_ptr` 和 `std::shared_ptr`。它们包装了原始指针，在析构时自动释放所指向的内存。这是现代C++取代 `new`/`delete` 的首选方式\n- STL容器：如 `std::vector`, `std::string` 等。它们在析构时会自动清理其内部动态分配的所有元素和内存缓冲区，无需手动管理\n\n&nbsp;\n\n### 9. 不要浪费时间和空间\n\n需要有意识地避免不必要的时间和空间开销。比如以下例子：\n\n```c++\nvoid lower(std::string s) \n{\n    for (unsigned int i = 0; i <= std::strlen(s.data()); ++i) \n    {\n        s[i] = std::tolower(s[i]);\n    }\n}\n```\n\n该函数想将字符串 `s` 转换为小写字符，但有以下问题：\n\n- 时间开销：`std::strlen(s.data())` 在每次循环迭代时都会被调用。`strlen` 是一个 O(n) 复杂度的函数，它需要遍历整个字符串直到找到空终止符 `\\0`。这导致一个原本是 O(n) 的循环变成了 O(n²)，对于长字符串会造成巨大的性能浪费\n-  传参错误：应传引用，传值并没有改动 `s`，并造成了额外的拷贝\n\n使用 `std::transform` 可以解决上述问题：\n\n```c++\nstd::transform(s.begin(), s.end(), s.begin(),\n              [](char c) { return std::tolower(c); });\n```\n\n下一个例子是抑制移动语义：\n\n```c++\nstruct S \n{\n    std::string s_;\n    S(std::string s): s_(s) {}\n    S(const S& rhs): s_(rhs.s_) {}\n    S& operator = (const S& rhs) { s_ = rhs.s_; return *this; }\n};\n\nS s1;\nS s2 = std::move(s1); // 这里执行的是拷贝，而非从 s1.s_ 移动\n```\n\nC++11 引入了移动语义，通过移动构造函数和移动赋值运算符实现。它将资源从一个临时对象（通常是右值）移动过来，而不是复制，成本低廉。\n\n但是在这个例子中，用户手动定义了拷贝构造函数和拷贝赋值运算符。根据C++标准规则，一旦用户显式定义了这些拷贝操作，编译器就不会自动生成默认的移动操作（移动构造函数和移动赋值运算符）。\n\n>但可以通过`= default`显式要求编译器生成移动操作\n\n因此，在代码 `S s2 = std::move(s1);` 中，`std::move(s1)` 本意是将 `s1` 转换为一个右值，期望触发移动操作。但由于 `S` 没有移动构造函数，编译器只能退而求其次，调用拷贝构造函数。这里的 `std::move` 实际上没有起到任何加速作用，反而产生了昂贵的拷贝开销。\n\n现代C++的最佳实践是“零规则”(Rule of Zero)：尽量避免手动定义拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符和析构函数。让编译器为你生成所有这些默认操作。在无需直接管理资源的大多数情况下，编译器生成的都是正确且最优的。\n\n如果类需要直接管理资源，确实需要自定义这些操作，那么应遵循 “五规则”(Rule of Five)：如果需要自定义其中任何一个，那么很可能需要同时自定义所有五个（拷贝构造、移动构造、拷贝赋值、移动赋值、析构），并正确地实现它们。\n\n&nbsp;\n\n### 10. 优先使用不可变数据而非可变数据\n\n不可变数据（常量）有以下优势：\n\n- 固化状态流转路径，降低代码复杂度\n- 利于编译期优化：包括常量传播、公共子表达式消除、死代码删除等编译优化技术\n- 并发安全\n\n&nbsp;\n\n### 11. 封装杂乱的构造，而非将其散布在代码中\n\n如果有可能，尽量不要自己实现复杂易错的底层代码，优先考虑类似 STL 这样的成熟代码库。\n\n如果找不到现成的高级库来替代必要的复杂逻辑，尽量将混乱、易变的细节隐藏在简洁的接口之中。\n\n&nbsp;\n\n### 12. 根据需要使用辅助工具\n\n使用如静态分析工具、并发分析工具、测试工具等辅助工具，可有效提高代码的正确性，可移植性和健壮性。\n\n不同的编译器（如 GCC, Clang, MSVC）对 C++ 标准的实现和理解略有不同，使用多种 C++ 编译器来编译代码，也是很好的验证代码的方式。\n\n&nbsp;\n\n### 13. 根据需要使用支持库\n\n根据需要使用高质量外部库可避免重复造轮子，提升开发效率和代码质量。\n\n&nbsp;\n\n## 2. Interfaces\n\n### 1. 避免使用非 `const` 的全局变量\n\n全局变量向函数内部注入了一个隐藏的依赖项，并且这个依赖项并非接口的一部分，容易出错，并且存在并发安全问题。\n\n&nbsp;\n\n### 2. 谨慎使用单例\n\n从本质上讲，单例也是一种全局变量。虽然它在很多场景下是有必要的，但我们在使用时也需要考虑以下问题：\n\n- 谁负责销毁单例？\n- 应该允许单例派生吗？\n- 如何以线程安全的方式初始化单例？\n- 当单例相互依赖且位于不同的编译单元时，它们的初始化顺序是怎样的？（静态初始化顺序问题）\n\n&nbsp;\n\n### 3. 书写好的接口\n\n好的接口应遵循以下规则：\n\n- 明确\n- 强类型\n- 尽可能少的参数\n- 避免相邻的、不相关的同类型参数\n\n结构体传参是一种好的写法，将复杂的参数列表封装为一个 `struct`，既很好地满足了上述规则，还使得接口的调整变得容易。如果接口需要新的参数，只需要在 `struct` 新增一个给出默认值的参数即可，所有的老代码依然正常调用，而无需到处修改。如：\n\n```c++\nstruct Light\n{\n    string name;\n    vec3 color;\n    int type;\n    double brightNess = .0; // 令 brightNess 默认为 0\n    vec3 loc;\n};\n```\n\n而所有的老代码依然可以正常调用，未指定的 `brightNess` 会具有默认值 `.0`\n\n```c++\nvoid buildLightPass({.name = \"Light1\", .color = {1, 1, 1}, .type = 1, .loc = {.0, .0, .0}});\n```\n\n同理，如果有必要的话，返回值也可以定义为结构体。\n\n对于返回值可能为空的的函数，或许空值语义是一种更好的写法。C++17 引入了 `std::optional`，形如 `std::optional<T>` 的类型有两种可能的状态：为空`nullopt` 和有值。这是一种语义更加明确的设计。\n\n&nbsp;\n\n### 4. 不要以指针的方式传递数组\n\n当我们将数组传递给一个入参是指针的函数时，数组会自动退化为其首元素的指针，所以往往还需要传递数组的大小。\n\n这是一种容易出错的写法，如果有可能的话使用 `std::vector` 作为函数的入参更好，但如果场景中为了满足入参不得不拷贝数据，从数组创建 `std::vector`，`std::span` 将是更好的选择。\n\n&nbsp;\n\n### 5. 为了稳定的 ABI，可考虑 Pimpl\n\n`Pimpl`（Pointer to Implementation）是 C++ 中的一种编译时封装技术，通过将类的实现细节隐藏在一个指向实现类的指针后面来减少编译依赖和提高封装性。\n\n> ABI 是二进制程序组件之间的接口，它定义了：\n>\n> - 内存布局：类/结构体的大小、成员偏移量\n>\n> - 函数调用约定：参数传递方式、栈清理责任\n>\n> - 名称修饰：C++ 函数名在二进制中的表示方式\n>\n> - 异常处理机制：异常如何抛出和捕获\n>\n> - 虚函数表布局：多态类的运行时结构\n\n基本结构\n\n```c++\nclass MyClass \n{\npublic:\n    MyClass();\n    ~MyClass();\n    void publicMethod();\n    \nprivate:\n    class Impl;  // 前向声明\n    std::unique_ptr<Impl> m_pImpl;  // 指向实现的指针\n};\n```\n\nPimpl 主要优势有两个：\n\n- 分离定义，加速编译（修改了具体实现 `Impl`，只需要重新编译 `MyClass.cpp`）\n- 可以保持 ABI 的稳定性，方便发布库更新和插件热装载\n\n其代价是每次访问实现都有一次指针间接寻址，有极轻微的性能损失，代码结构更加复杂。适用于大型类（有很多的私有成员和方法），库开发（需要保持二进制的兼容性），编译时间敏感等场景。\n\n&nbsp;\n\n## 3. Functions\n\n### 1. 函数定义\n\n定义一个函数首先需要考虑如何命名，好的函数命名并无铁律，不过这里仍有三条实用的建议：\n\n- 取有意义的名字\n- 函数应该执行单个逻辑操作\n- 保持函数简洁\n\n&nbsp;\n\n如果一个函数在编译期求值，应将其声明为 `constexpr`：\n\n- 当在一个常量表达式中调用 `constexpr` 函数，或者将其结果赋值一个 `constexpr` 变量时，它会在编译期执行\n\n- `constexpr` 函数并非只能在编译期执行，当传递给它的参数是运行时才能确定的，或者没有强制要求结果是常量，那么它将退化成在运行时执行\n\n- 当函数在编译期执行完成后，计算结果作为一个普通的字面常量存储在 ROM(Read Only Memory) 中，通常对应可执行文件中的 `.rodata` 段（只读数据段）\n\n- `constexpr` 函数是隐式内联的，这意味着可以（并且通常应该将 `constexpr` 函数的定义写在头文件中）\n\n  >如果是普通函数，那么编译器并不需要知道函数的具体实现，因为链接器 (Linker) 稍后会负责找到它。\n  >\n  >但如果是 `constexpr` 函数，函数的完整定义必对当前编译的文件可见。最简单直接的方式就是将完整定义写在头文件里（也有一些其他实现方法：如 C++ 20 Modules，Untiy Build[单编译单元构建]等）\n  >\n  >引申：如果是一个普通函数的定义写在了头文件里，是一种禁忌：\n  >\n  >- 当两个 `.cpp` 源文件都包含这个头文件时，将分别生成两个同名符号，链接器在链接时无法区分，于是报错`Multiple definition of 'add'`（重定义错误）\n  >\n  >- 这违背了 ODR（One Definition Rule，单一定义规则）：一个非内联函数在整个程序中只能有一个定义\n  >-  `inline` 现在真正的作用是让多个翻译单元共享同一个定义，突破单一定义规则，可以解决这个问题\n\n- `constexpr` 函数天然线程安全\n\n&nbsp;\n\n如果函数不会抛出异常，应将其声明为 `noexcept`\n\n&nbsp;\n\n# 2. C++ 基础\n\n## 1. 平凡类型（Trivial Type）\n\nC++11 引入平凡类型的概念，用于描述“没有副作用的构造/析构/赋值等操作”的类型，一个类型是平凡类型当且仅当它满足以下所有条件：\n\n- 无用户定义的构造函数\n- 无用户定义的析构函数\n- 无用户定义的拷贝/移动构造函数\n- 无用户定义的拷贝/移动赋值操作符\n- 无虚函数，无虚基类\n- 所有非静态成员和基类都是平凡的\n\n可使用 `std::is_trivial` 进行判别。\n\nPOD 类型（Plain Old Data）相比于平凡类型是一个更严格、更古老的限制。在平凡类型的基础上还有标准布局（Standard Layout）的要求。\n\n标准布局类型满足以下条件：\n\n- 所有非静态成员具有相同的访问控制\n- 无虚函数，无虚基类\n- 没有引用类型的非静态数据成员\n- 所有非静态数据成员都是标准布局类型\n- 所有基类都是标准布局类型\n- 满足以下继承条件之一：\n  - 没有基类\n  - 只有一个基类且没有非静态数据成员\n  - 基类和派生类中不能同时有非静态数据成员\n\n可使用 `std::is_standard_layout_v` 判别是否是标准布局类型。\n\nPOD 类型也有 `std::is_pod` 这样的判断方法，但是该方法已经在 C++20 中被移除，不推荐使用。可通过 `std::is_standard_layout_v` 和 `std::is_trivial` 的组合来达到相同的目的。即：\n\n>POD = Trivial && Standard Layout\n\n```c++\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\nvoid checkTypeProperties() \n{\n    std::cout << \"Type: \" << typeid(T).name() << \"\\n\";\n    std::cout << \"Is trivial: \" << std::is_trivial_v<T> << \"\\n\";\n    std::cout << \"Is standard layout: \" << std::is_standard_layout_v<T> << \"\\n\";\n    std::cout << \"Is POD: \" << std::is_pod_v<T> << \"\\n\";\n    std::cout << \"---\\n\";\n}\n\n// POD类型\nstruct POD_Example \n{        \n    int a;\n    char b;\n};\n\n// 平凡但非POD\nstruct TrivialNonPOD1 \n{     \npublic:\n    int public_member;\nprivate:\n    int private_member;\n};\n\n// 继承破坏标准布局\nstruct TrivialNonPOD2 : POD_Example \n{  \n    int additional_member;\n};\n\nint main() \n{\n    checkTypeProperties<POD_Example>();\n    checkTypeProperties<TrivialNonPOD1>();\n    checkTypeProperties<TrivialNonPOD2>();\n    return 0;\n}\n```\n\n\n\n**应用场景**\n\n- 平凡类型\n\n  其核心特性在于可以使用 `memcpy` 等低级内存操作进行复制，而不需要逐个调用拷贝构造函数，在需要高效移动和复制时很有用。\n  \n  ```c++\n  // 高效内存复制\n  template<typename T>\n  void trivial_copy(const T* src, T* dest, size_t count) \n  {\n      static_assert(std::is_trivial_v<T>, \n      \"Type must be trivial for memcpy operations\");\n      std::memcpy(dest, src, count * sizeof(T));\n  }\n  \n  // 序列化/反序列化\n  struct TrivialData \n  {\n      int id;\n      double value;\n      char name[32];\n  };\n  void serialize_trivial(const TrivialData& data, char* buffer) \n  {\n      // 安全地直接复制内存\n      std::memcpy(buffer, &data, sizeof(TrivialData));\n  }\n  \n  // 对象池和内存管理\n  template<typename T>\n  class ObjectPool \n  {\n      static_assert(std::is_trivial_v<T>, \"ObjectPool requires trivial types for efficient reuse\");\n      std::vector<T> pool;\n  public:\n      T* allocate() \n      {\n          // 可以安全地重用内存而不调用析构函数\n          return &pool.emplace_back();\n      }\n  };\n  ```\n  \n- 标准布局类型\n\n  其核心特性是确定性的内存布局，并与 C 语言兼容\n\n  ```c++\n  // 与C语言互操作\n  extern \"C\" \n  {\n      struct CStruct \n      {\n          int x;\n          double y;\n      };\n      void process_c_struct(CStruct* data);\n  }\n  struct CompatibleCppStruct \n  {\n      int x;\n      double y;\n  }; // 标准布局，可以与C结构体安全互操作\n  static_assert(std::is_standard_layout_v<CompatibleCppStruct>);\n  \n  // 硬件寄存器映射\n  struct DeviceRegisterMap \n  {\n      volatile uint32_t control;\n      volatile uint32_t status;\n      volatile uint32_t data;\n  }; // 标准布局确保成员顺序与硬件寄存器一致\n  \n  // 网络协议数据包\n  #pragma pack(push, 1)\n  struct NetworkPacket \n  {\n      uint16_t header;\n      uint32_t sequence;\n      uint8_t payload[1024];\n      uint16_t checksum;\n  }; // 标准布局 + 打包确保精确的内存布局\n  #pragma pack(pop)\n  \n  // 通过偏移量访问成员\n  template<typename T, typename M>\n  size_t member_offset(M T::*member) \n  {\n      static_assert(std::is_standard_layout_v<T>);\n      return reinterpret_cast<size_t>(&(reinterpret_cast<T*>(0)->*member));\n  } // 只有标准布局类型才有确定的成员偏移量\n  ```\n\n- POD 类型\n\n  同时拥有以上两种类型的特性，是二者的交集。但现代 C++ 编码中应尽量避免使用这个概念。\n\n----\n\n**Reference**\n\n- [*C++ Core Guidelines Explained: Best Practices for Modern C++*](https://www.google.com/books/edition/C++_Core_Guidelines_Explained/ptnPEAAAQBAJ?hl=en&gbpv=0)\n- [*现代 C++ 教程*](https://www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.788.comment.all.click&vd_source=aec47f6b52af3774b903cb0d25607f6c)\n- [*小彭大典*](https://parallel101.github.io/cppguidebook/)","slug":"C-General","published":true,"updated":"2025-11-23T08:30:45.270Z","_id":"cmhrudxky00005kcn5jz2f7fa","comments":true,"layout":"post","photos":[],"html":"<h1>1. C++ 设计准则</h1>\n<h2 id=\"1-Philosophy\">1. Philosophy</h2>\n<h3 id=\"1-保持代码直观清晰\">1. 保持代码直观清晰</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Month <span class=\"title\">month</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>; <span class=\"comment\">// do</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">month</span><span class=\"params\">()</span></span>; <span class=\"comment\">// don&#x27;t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，前者是更好的写法，它的返回值是类型明确的，并且本身具有 const 限定。</p>\n<p> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; v.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(v[i] == val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        index = i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// bad</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find</span>(std::<span class=\"built_in\">begin</span>(v), std::<span class=\"built_in\">end</span>(v), val); <span class=\"comment\">// better</span></span><br></pre></td></tr></table></figure>\n<p>使用 STL 能使代码更加清晰简洁，不易出错。有一句现代 C++ 谚语：如果你还在显式地使用循环，那么你就没有真正理解 STL 算法。</p>\n<p> </p>\n<h3 id=\"2-遵循-ISO-Standard\">2. 遵循 ISO Standard</h3>\n<p>按照由国际标准化组织（ISO）制定并发布的《ISO/IEC 14882》C++ 标准来编写代码。</p>\n<p>这意味着尽量避免依赖各编译器厂商（如 GCC、MSVC、Clang）提供的额外语法或库扩展，以保证代码在不同环境下都能编译和运行。</p>\n<p>另外，需要注意 Undefined Behavior 和 Implementation‑Defined Behavior</p>\n<ul>\n<li>\n<p>Undefined Behavior</p>\n<p>指 C++ 标准未明确规定行为规范的代码操作，允许编译器自由处理。程序可能崩溃、产生错误结果、或看似正常运行实则存在隐患。程序应避免任何 UB。</p>\n<p><a href=\"https://parallel101.github.io/cppguidebook/undef/\"><em>未定义行为完整列表</em></a></p>\n</li>\n<li>\n<p>Implementation‑Defined Behavior</p>\n<p>指 C++ 标准允许编译器或运行时环境自由选择具体实现方式，但要求该行为必须被明确文档化。虽然具有平台依赖性，但结果是可预测的，由特定编译器的实现文档保证。</p>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"3-注释应写明意图\">3. 注释应写明意图</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; v : vec) &#123;...&#125; <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; v : vec) &#123;...&#125; <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::for_each(std::execution::par, vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">auto</span>&amp; v) &#123;...&#125;); <span class=\"comment\">// (3)</span></span><br></pre></td></tr></table></figure>\n<p>上述示例中，(1) 与 (2) 的区别在于前者不会修改容器中的元素。</p>\n<p>(3) 是使用并行的方式对容器中的每个元素执行一个操作。但是需要注意的小规模数据可能因线程调度开销导致性能下降，这种写法更适用于大规模数据。</p>\n<p>总之，注释应阐明意图，指出应该做什么。</p>\n<p> </p>\n<h3 id=\"4-保证程序的静态类型安全\">4. 保证程序的静态类型安全</h3>\n<p>C++ 是静态类型语言。即所有的变量或表达式的类型必须在编译时确定。静态类型安全要求编译器不仅知道其类型，还要能检测出类型相关的错误。C++ 并非完全类型安全，因此需要在编写代码时人工规避问题。</p>\n<p>以下是常见的类型安全的问题及规避方案：</p>\n<ul>\n<li>\n<p>联合体（Union）</p>\n<p>联合体允许不同类型共享同一内存空间，同一时间只能存储一个成员的值，可以达到节省内存的效果，<code>union</code> 的大小等于其最大成员的大小；</p>\n<p><code>union</code> 不记录当前活跃的成员，访问错误的成员会导致未定义行为。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">Data</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">float</span> f;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Data data;</span><br><span class=\"line\">data.i = <span class=\"number\">10</span>;</span><br><span class=\"line\">std::cout &lt;&lt; data.f &lt;&lt; std::endl; <span class=\"comment\">// 错误：此时通过 f 访问是未定义行为</span></span><br></pre></td></tr></table></figure>\n<p>在 C++11 之前，<code>union</code> 仅支持平凡类型。C++11 之后可以包含非平凡类型，但有严格限制。必须提供自定义构造函数，因为 <code>union</code> 的默认构造函数是 <code>delete</code> 状态。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">MyUnion</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    std::string s;  <span class=\"comment\">// 非平凡类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 编译器不会生成默认构造函数</span></span><br><span class=\"line\">    <span class=\"comment\">// MyUnion() = delete;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// MyUnion u;  // 错误,默认构造函数被删除</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>必须显式管理生命周期和追踪活跃成员，比如析构时需要识别出活跃成员，否则析构出错会有未定义行为。</p>\n<p>C++17 引入了 <code>std::variant</code>，它是一个类型安全的联合体。可以方便地存储非平凡类型，并且自动管理存储资源的生命周期，是 <code>union</code> 的上位替代。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::variant&lt;<span class=\"type\">int</span>, std::string&gt; v = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要知道类型进行访问</span></span><br><span class=\"line\">std::cout &lt;&lt; std::<span class=\"built_in\">get</span>&lt;std::string&gt;(v) &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类型安全的访问方式</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span>* str = std::<span class=\"built_in\">get_if</span>&lt;std::string&gt;(&amp;v)) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *str &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>类型转换</p>\n<p>显式类型转换（如 <code>static_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code>）可能引发错误或未定义行为</p>\n<blockquote>\n<p><code>dynamic_cast</code> 相对安全，有运行时类型检查。对于指针类型，转换失败会返回空指针；对于引用类型，转换失败会抛出 <code>std::bad_cast</code> 异常。</p>\n</blockquote>\n<p>而基于模板的泛型代码减少了对类型转换的需求，从某种程度上可以减少此类错误。</p>\n</li>\n<li>\n<p>数组退化</p>\n<p>C 风格数组在传递给函数时，会退化为指向其首元素的指针，丢失数组大小信息。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processArray</span><span class=\"params\">(<span class=\"type\">int</span> arr[])</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里 arr 实际上是指针，不是数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 输出指针大小(8/4字节)，无法获取原始数组大小</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size in function: &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr) &lt;&lt; std::endl; \t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C++20 提供的 <code>std::span</code> 是一个轻量级的视图，包含指针和大小信息，提供安全的数组访问，可以解决这个问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;span&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;array&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 std::span 接收数组，自动保持大小信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processWithSpan</span><span class=\"params\">(std::span&lt;<span class=\"type\">int</span>&gt; arr)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Span size: &quot;</span> &lt;&lt; arr.<span class=\"built_in\">size</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Span data: &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> value : arr) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 安全的索引访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); i++) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 子视图，同样安全</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.<span class=\"built_in\">size</span>() &gt;= <span class=\"number\">3</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> subspan = arr.<span class=\"built_in\">subspan</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 从索引1开始，取2个元素</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Subspan: &quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> val : subspan) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. C 风格数组，自动推导大小</span></span><br><span class=\"line\">    <span class=\"type\">int</span> cArray[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">processWithSpan</span>(cArray); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. std::array</span></span><br><span class=\"line\">    std::array&lt;<span class=\"type\">int</span>, 4&gt; stdArray = &#123; <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">processWithSpan</span>(stdArray);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. std::vector</span></span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; vec = &#123; <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">processWithSpan</span>(vec);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 动态数组，需要显式提供大小</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* dynamicArray = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">3</span>] &#123;<span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">processWithSpan</span>(std::<span class=\"built_in\">span</span>&lt;<span class=\"type\">int</span>&gt;(dynamicArray, <span class=\"number\">3</span>)); </span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] dynamicArray;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，动态数组的大小在运行时确定，编译期无法推导，所以需要显式提供大小。而 <code>std::vector</code> 因为它本身是包含 size 信息的完整类型，所以即使其 size 是在运行期确定的，也无需向 <code>std::span</code> 显式提供大小。</p>\n</li>\n<li>\n<p>窄化转换</p>\n<p>隐式转换可能导致数据丢失（如 <code>double</code> → <code>int</code> 截断小数）</p>\n<p>使用 <code>&#123;&#125;</code> 初始化（列表初始化）时，编译器会强制检查并拒绝窄化转换，帮助在编译期捕获此类错误。</p>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"5-优先编译期检查而非运行期检查\">5. 优先编译期检查而非运行期检查</h3>\n<p>所有能够在编译期进行的检查，都应当置于编译期完成。C++11 引入编译期断言 <code>static_assert</code> ，它接受一个常量表达式，在编译期验证条件，对条件不满足或者运行期才能确定的表达式产生编译错误。</p>\n<p>此外，类型特征库（type-traits library）允许开发者构建强大的条件检查：例如<code>static_assert(std::is_integral&lt;T&gt;::value)</code>。</p>\n<p> </p>\n<h3 id=\"6-无法在编译期检查的内容，应当能够在运行期进行检查\">6. 无法在编译期检查的内容，应当能够在运行期进行检查</h3>\n<p>借助 <code>dynamic_cast</code>，我们能够安全地在继承层次结构中向上、向下及横向转换类的指针和引用。如果转换失败，对于指针会返回 <code>nullptr</code>，对于引用则会抛出 <code>std::bad_cast</code> 异常</p>\n<p><code>dynamic_cast</code> 依赖于运行时类型信息（Run-Time Type Information, RTTI），而 RTTI 只对多态类型（即包含虚函数的类）可用。</p>\n<blockquote>\n<p>编译器在 <code>vtable</code> 中嵌入 <code>type_info</code> 对象，非多态类类型没有 <code>vtable</code>，因此没有存储类型信息的地方，<code>dynamic_cast</code> 通过查询对象的 <code>type_info</code> 来验证转换的合法性</p>\n</blockquote>\n<p>  </p>\n<h3 id=\"7-尽早捕获运行期错误\">7. 尽早捕获运行期错误</h3>\n<p>可采用多种对策消除运行时错误。比如检查指针、数组范围、类型转换等，避免错误的传播和扩散。</p>\n<p> </p>\n<h3 id=\"8-不要泄露任何资源\">8. 不要泄露任何资源</h3>\n<p>资源不仅指内存，还包括系统资源，如文件句柄、网络套接字、数据库连接、图形界面句柄、互斥锁等</p>\n<p>任何资源如果只申请不释放，都会随着程序的运行而不断累积。对于需要长时间运行的服务端程序或后台进程，即使是微小的泄露，最终也可能耗尽系统资源，导致程序崩溃或系统变得不稳定。</p>\n<p>处理资源的惯用方法是 RAII (Resource Acquisition Is Initialization)：</p>\n<ul>\n<li>将资源的生命周期与一个对象的生命周期绑定</li>\n<li>在对象的构造函数中获取资源</li>\n<li>在对象的析构函数中释放资源</li>\n<li>C++保证，当对象离开其作用域时（无论是正常离开，还是因为异常而离开），其析构函数一定会被自动调用，无需手动干预</li>\n</ul>\n<blockquote>\n<p>成员对象的析构函数在持有它的类析构时会自动调用，但它持有的资源是否需要手动释放，取决于该成员类型本身的实现</p>\n</blockquote>\n<p>RAII 应用示例：</p>\n<ul>\n<li>锁：如 <code>std::lock_guard</code> 或 <code>std::unique_lock</code>。在构造时锁定互斥量，在析构时自动解锁。这防止了因忘记解锁而导致的死锁</li>\n<li>智能指针：如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>。它们包装了原始指针，在析构时自动释放所指向的内存。这是现代C++取代 <code>new</code>/<code>delete</code> 的首选方式</li>\n<li>STL容器：如 <code>std::vector</code>, <code>std::string</code> 等。它们在析构时会自动清理其内部动态分配的所有元素和内存缓冲区，无需手动管理</li>\n</ul>\n<p> </p>\n<h3 id=\"9-不要浪费时间和空间\">9. 不要浪费时间和空间</h3>\n<p>需要有意识地避免不必要的时间和空间开销。比如以下例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lower</span><span class=\"params\">(std::string s)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">unsigned</span> <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= std::<span class=\"built_in\">strlen</span>(s.<span class=\"built_in\">data</span>()); ++i) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s[i] = std::<span class=\"built_in\">tolower</span>(s[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数想将字符串 <code>s</code> 转换为小写字符，但有以下问题：</p>\n<ul>\n<li>时间开销：<code>std::strlen(s.data())</code> 在每次循环迭代时都会被调用。<code>strlen</code> 是一个 O(n) 复杂度的函数，它需要遍历整个字符串直到找到空终止符 <code>\\0</code>。这导致一个原本是 O(n) 的循环变成了 O(n²)，对于长字符串会造成巨大的性能浪费</li>\n<li>传参错误：应传引用，传值并没有改动 <code>s</code>，并造成了额外的拷贝</li>\n</ul>\n<p>使用 <code>std::transform</code> 可以解决上述问题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">transform</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>(), s.<span class=\"built_in\">begin</span>(),</span><br><span class=\"line\">              [](<span class=\"type\">char</span> c) &#123; <span class=\"keyword\">return</span> std::<span class=\"built_in\">tolower</span>(c); &#125;);</span><br></pre></td></tr></table></figure>\n<p>下一个例子是抑制移动语义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">S</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::string s_;</span><br><span class=\"line\">    <span class=\"built_in\">S</span>(std::string s): <span class=\"built_in\">s_</span>(s) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">S</span>(<span class=\"type\">const</span> S&amp; rhs): <span class=\"built_in\">s_</span>(rhs.s_) &#123;&#125;</span><br><span class=\"line\">    S&amp; <span class=\"keyword\">operator</span> = (<span class=\"type\">const</span> S&amp; rhs) &#123; s_ = rhs.s_; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">S s1;</span><br><span class=\"line\">S s2 = std::<span class=\"built_in\">move</span>(s1); <span class=\"comment\">// 这里执行的是拷贝，而非从 s1.s_ 移动</span></span><br></pre></td></tr></table></figure>\n<p>C++11 引入了移动语义，通过移动构造函数和移动赋值运算符实现。它将资源从一个临时对象（通常是右值）移动过来，而不是复制，成本低廉。</p>\n<p>但是在这个例子中，用户手动定义了拷贝构造函数和拷贝赋值运算符。根据C++标准规则，一旦用户显式定义了这些拷贝操作，编译器就不会自动生成默认的移动操作（移动构造函数和移动赋值运算符）。</p>\n<blockquote>\n<p>但可以通过<code>= default</code>显式要求编译器生成移动操作</p>\n</blockquote>\n<p>因此，在代码 <code>S s2 = std::move(s1);</code> 中，<code>std::move(s1)</code> 本意是将 <code>s1</code> 转换为一个右值，期望触发移动操作。但由于 <code>S</code> 没有移动构造函数，编译器只能退而求其次，调用拷贝构造函数。这里的 <code>std::move</code> 实际上没有起到任何加速作用，反而产生了昂贵的拷贝开销。</p>\n<p>现代C++的最佳实践是“零规则”(Rule of Zero)：尽量避免手动定义拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符和析构函数。让编译器为你生成所有这些默认操作。在无需直接管理资源的大多数情况下，编译器生成的都是正确且最优的。</p>\n<p>如果类需要直接管理资源，确实需要自定义这些操作，那么应遵循 “五规则”(Rule of Five)：如果需要自定义其中任何一个，那么很可能需要同时自定义所有五个（拷贝构造、移动构造、拷贝赋值、移动赋值、析构），并正确地实现它们。</p>\n<p> </p>\n<h3 id=\"10-优先使用不可变数据而非可变数据\">10. 优先使用不可变数据而非可变数据</h3>\n<p>不可变数据（常量）有以下优势：</p>\n<ul>\n<li>固化状态流转路径，降低代码复杂度</li>\n<li>利于编译期优化：包括常量传播、公共子表达式消除、死代码删除等编译优化技术</li>\n<li>并发安全</li>\n</ul>\n<p> </p>\n<h3 id=\"11-封装杂乱的构造，而非将其散布在代码中\">11. 封装杂乱的构造，而非将其散布在代码中</h3>\n<p>如果有可能，尽量不要自己实现复杂易错的底层代码，优先考虑类似 STL 这样的成熟代码库。</p>\n<p>如果找不到现成的高级库来替代必要的复杂逻辑，尽量将混乱、易变的细节隐藏在简洁的接口之中。</p>\n<p> </p>\n<h3 id=\"12-根据需要使用辅助工具\">12. 根据需要使用辅助工具</h3>\n<p>使用如静态分析工具、并发分析工具、测试工具等辅助工具，可有效提高代码的正确性，可移植性和健壮性。</p>\n<p>不同的编译器（如 GCC, Clang, MSVC）对 C++ 标准的实现和理解略有不同，使用多种 C++ 编译器来编译代码，也是很好的验证代码的方式。</p>\n<p> </p>\n<h3 id=\"13-根据需要使用支持库\">13. 根据需要使用支持库</h3>\n<p>根据需要使用高质量外部库可避免重复造轮子，提升开发效率和代码质量。</p>\n<p> </p>\n<h2 id=\"2-Interfaces\">2. Interfaces</h2>\n<h3 id=\"1-避免使用非-const-的全局变量\">1. 避免使用非 <code>const</code> 的全局变量</h3>\n<p>全局变量向函数内部注入了一个隐藏的依赖项，并且这个依赖项并非接口的一部分，容易出错，并且存在并发安全问题。</p>\n<p> </p>\n<h3 id=\"2-谨慎使用单例\">2. 谨慎使用单例</h3>\n<p>从本质上讲，单例也是一种全局变量。虽然它在很多场景下是有必要的，但我们在使用时也需要考虑以下问题：</p>\n<ul>\n<li>谁负责销毁单例？</li>\n<li>应该允许单例派生吗？</li>\n<li>如何以线程安全的方式初始化单例？</li>\n<li>当单例相互依赖且位于不同的编译单元时，它们的初始化顺序是怎样的？（静态初始化顺序问题）</li>\n</ul>\n<p> </p>\n<h3 id=\"3-书写好的接口\">3. 书写好的接口</h3>\n<p>好的接口应遵循以下规则：</p>\n<ul>\n<li>明确</li>\n<li>强类型</li>\n<li>尽可能少的参数</li>\n<li>避免相邻的、不相关的同类型参数</li>\n</ul>\n<p>结构体传参是一种好的写法，将复杂的参数列表封装为一个 <code>struct</code>，既很好地满足了上述规则，还使得接口的调整变得容易。如果接口需要新的参数，只需要在 <code>struct</code> 新增一个给出默认值的参数即可，所有的老代码依然正常调用，而无需到处修改。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Light</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    vec3 color;</span><br><span class=\"line\">    <span class=\"type\">int</span> type;</span><br><span class=\"line\">    <span class=\"type\">double</span> brightNess = <span class=\"number\">.0</span>; <span class=\"comment\">// 令 brightNess 默认为 0</span></span><br><span class=\"line\">    vec3 loc;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>而所有的老代码依然可以正常调用，未指定的 <code>brightNess</code> 会具有默认值 <code>.0</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">buildLightPass</span><span class=\"params\">(&#123;.name = <span class=\"string\">&quot;Light1&quot;</span>, .color = &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, .type = <span class=\"number\">1</span>, .loc = &#123;<span class=\"number\">.0</span>, <span class=\"number\">.0</span>, <span class=\"number\">.0</span>&#125;&#125;)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>同理，如果有必要的话，返回值也可以定义为结构体。</p>\n<p>对于返回值可能为空的的函数，或许空值语义是一种更好的写法。C++17 引入了 <code>std::optional</code>，形如 <code>std::optional&lt;T&gt;</code> 的类型有两种可能的状态：为空<code>nullopt</code> 和有值。这是一种语义更加明确的设计。</p>\n<p> </p>\n<h3 id=\"4-不要以指针的方式传递数组\">4. 不要以指针的方式传递数组</h3>\n<p>当我们将数组传递给一个入参是指针的函数时，数组会自动退化为其首元素的指针，所以往往还需要传递数组的大小。</p>\n<p>这是一种容易出错的写法，如果有可能的话使用 <code>std::vector</code> 作为函数的入参更好，但如果场景中为了满足入参不得不拷贝数据，从数组创建 <code>std::vector</code>，<code>std::span</code> 将是更好的选择。</p>\n<p> </p>\n<h3 id=\"5-为了稳定的-ABI，可考虑-Pimpl\">5. 为了稳定的 ABI，可考虑 Pimpl</h3>\n<p><code>Pimpl</code>（Pointer to Implementation）是 C++ 中的一种编译时封装技术，通过将类的实现细节隐藏在一个指向实现类的指针后面来减少编译依赖和提高封装性。</p>\n<blockquote>\n<p>ABI 是二进制程序组件之间的接口，它定义了：</p>\n<ul>\n<li>\n<p>内存布局：类/结构体的大小、成员偏移量</p>\n</li>\n<li>\n<p>函数调用约定：参数传递方式、栈清理责任</p>\n</li>\n<li>\n<p>名称修饰：C++ 函数名在二进制中的表示方式</p>\n</li>\n<li>\n<p>异常处理机制：异常如何抛出和捕获</p>\n</li>\n<li>\n<p>虚函数表布局：多态类的运行时结构</p>\n</li>\n</ul>\n</blockquote>\n<p>基本结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">publicMethod</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Impl</span>;  <span class=\"comment\">// 前向声明</span></span><br><span class=\"line\">    std::unique_ptr&lt;Impl&gt; m_pImpl;  <span class=\"comment\">// 指向实现的指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Pimpl 主要优势有两个：</p>\n<ul>\n<li>分离定义，加速编译（修改了具体实现 <code>Impl</code>，只需要重新编译 <code>MyClass.cpp</code>）</li>\n<li>可以保持 ABI 的稳定性，方便发布库更新和插件热装载</li>\n</ul>\n<p>其代价是每次访问实现都有一次指针间接寻址，有极轻微的性能损失，代码结构更加复杂。适用于大型类（有很多的私有成员和方法），库开发（需要保持二进制的兼容性），编译时间敏感等场景。</p>\n<p> </p>\n<h2 id=\"3-Functions\">3. Functions</h2>\n<h3 id=\"1-函数定义\">1. 函数定义</h3>\n<p>定义一个函数首先需要考虑如何命名，好的函数命名并无铁律，不过这里仍有三条实用的建议：</p>\n<ul>\n<li>取有意义的名字</li>\n<li>函数应该执行单个逻辑操作</li>\n<li>保持函数简洁</li>\n</ul>\n<p> </p>\n<p>如果一个函数在编译期求值，应将其声明为 <code>constexpr</code>：</p>\n<ul>\n<li>\n<p>当在一个常量表达式中调用 <code>constexpr</code> 函数，或者将其结果赋值一个 <code>constexpr</code> 变量时，它会在编译期执行</p>\n</li>\n<li>\n<p><code>constexpr</code> 函数并非只能在编译期执行，当传递给它的参数是运行时才能确定的，或者没有强制要求结果是常量，那么它将退化成在运行时执行</p>\n</li>\n<li>\n<p>当函数在编译期执行完成后，计算结果作为一个普通的字面常量存储在 ROM(Read Only Memory) 中，通常对应可执行文件中的 <code>.rodata</code> 段（只读数据段）</p>\n</li>\n<li>\n<p><code>constexpr</code> 函数是隐式内联的，这意味着可以（并且通常应该将 <code>constexpr</code> 函数的定义写在头文件中）</p>\n<blockquote>\n<p>如果是普通函数，那么编译器并不需要知道函数的具体实现，因为链接器 (Linker) 稍后会负责找到它。</p>\n<p>但如果是 <code>constexpr</code> 函数，函数的完整定义必对当前编译的文件可见。最简单直接的方式就是将完整定义写在头文件里（也有一些其他实现方法：如 C++ 20 Modules，Untiy Build[单编译单元构建]等）</p>\n<p>引申：如果是一个普通函数的定义写在了头文件里，是一种禁忌：</p>\n<ul>\n<li>\n<p>当两个 <code>.cpp</code> 源文件都包含这个头文件时，将分别生成两个同名符号，链接器在链接时无法区分，于是报错<code>Multiple definition of 'add'</code>（重定义错误）</p>\n</li>\n<li>\n<p>这违背了 ODR（One Definition Rule，单一定义规则）：一个非内联函数在整个程序中只能有一个定义</p>\n</li>\n<li>\n<p><code>inline</code> 现在真正的作用是让多个翻译单元共享同一个定义，突破单一定义规则，可以解决这个问题</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><code>constexpr</code> 函数天然线程安全</p>\n</li>\n</ul>\n<p> </p>\n<p>如果函数不会抛出异常，应将其声明为 <code>noexcept</code></p>\n<p> </p>\n<h1>2. C++ 基础</h1>\n<h2 id=\"1-平凡类型（Trivial-Type）\">1. 平凡类型（Trivial Type）</h2>\n<p>C++11 引入平凡类型的概念，用于描述“没有副作用的构造/析构/赋值等操作”的类型，一个类型是平凡类型当且仅当它满足以下所有条件：</p>\n<ul>\n<li>无用户定义的构造函数</li>\n<li>无用户定义的析构函数</li>\n<li>无用户定义的拷贝/移动构造函数</li>\n<li>无用户定义的拷贝/移动赋值操作符</li>\n<li>无虚函数，无虚基类</li>\n<li>所有非静态成员和基类都是平凡的</li>\n</ul>\n<p>可使用 <code>std::is_trivial</code> 进行判别。</p>\n<p>POD 类型（Plain Old Data）相比于平凡类型是一个更严格、更古老的限制。在平凡类型的基础上还有标准布局（Standard Layout）的要求。</p>\n<p>标准布局类型满足以下条件：</p>\n<ul>\n<li>所有非静态成员具有相同的访问控制</li>\n<li>无虚函数，无虚基类</li>\n<li>没有引用类型的非静态数据成员</li>\n<li>所有非静态数据成员都是标准布局类型</li>\n<li>所有基类都是标准布局类型</li>\n<li>满足以下继承条件之一：\n<ul>\n<li>没有基类</li>\n<li>只有一个基类且没有非静态数据成员</li>\n<li>基类和派生类中不能同时有非静态数据成员</li>\n</ul>\n</li>\n</ul>\n<p>可使用 <code>std::is_standard_layout_v</code> 判别是否是标准布局类型。</p>\n<p>POD 类型也有 <code>std::is_pod</code> 这样的判断方法，但是该方法已经在 C++20 中被移除，不推荐使用。可通过 <code>std::is_standard_layout_v</code> 和 <code>std::is_trivial</code> 的组合来达到相同的目的。即：</p>\n<blockquote>\n<p>POD = Trivial &amp;&amp; Standard Layout</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checkTypeProperties</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Type: &quot;</span> &lt;&lt; <span class=\"built_in\">typeid</span>(T).<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is trivial: &quot;</span> &lt;&lt; std::is_trivial_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is standard layout: &quot;</span> &lt;&lt; std::is_standard_layout_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is POD: &quot;</span> &lt;&lt; std::is_pod_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;---\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POD类型</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">POD_Example</span> </span><br><span class=\"line\">&#123;        </span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">char</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 平凡但非POD</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialNonPOD1</span> </span><br><span class=\"line\">&#123;     </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> public_member;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> private_member;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承破坏标准布局</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialNonPOD2</span> : POD_Example </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"type\">int</span> additional_member;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;POD_Example&gt;();</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;TrivialNonPOD1&gt;();</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;TrivialNonPOD2&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>\n<p>平凡类型</p>\n<p>其核心特性在于可以使用 <code>memcpy</code> 等低级内存操作进行复制，而不需要逐个调用拷贝构造函数，在需要高效移动和复制时很有用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 高效内存复制</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">trivial_copy</span><span class=\"params\">(<span class=\"type\">const</span> T* src, T* dest, <span class=\"type\">size_t</span> count)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_trivial_v&lt;T&gt;, </span><br><span class=\"line\">    <span class=\"string\">&quot;Type must be trivial for memcpy operations&quot;</span>);</span><br><span class=\"line\">    std::<span class=\"built_in\">memcpy</span>(dest, src, count * <span class=\"built_in\">sizeof</span>(T));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 序列化/反序列化</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialData</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">double</span> value;</span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">32</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">serialize_trivial</span><span class=\"params\">(<span class=\"type\">const</span> TrivialData&amp; data, <span class=\"type\">char</span>* buffer)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 安全地直接复制内存</span></span><br><span class=\"line\">    std::<span class=\"built_in\">memcpy</span>(buffer, &amp;data, <span class=\"built_in\">sizeof</span>(TrivialData));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象池和内存管理</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_trivial_v&lt;T&gt;, <span class=\"string\">&quot;ObjectPool requires trivial types for efficient reuse&quot;</span>);</span><br><span class=\"line\">    std::vector&lt;T&gt; pool;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">T* <span class=\"title\">allocate</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以安全地重用内存而不调用析构函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;pool.<span class=\"built_in\">emplace_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>标准布局类型</p>\n<p>其核心特性是确定性的内存布局，并与 C 语言兼容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 与C语言互操作</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">CStruct</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        <span class=\"type\">double</span> y;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process_c_struct</span><span class=\"params\">(CStruct* data)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CompatibleCppStruct</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">double</span> y;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局，可以与C结构体安全互操作</span></span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(std::is_standard_layout_v&lt;CompatibleCppStruct&gt;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 硬件寄存器映射</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">DeviceRegisterMap</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> control;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> status;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> data;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局确保成员顺序与硬件寄存器一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 网络协议数据包</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(push, 1)</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">NetworkPacket</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> header;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> sequence;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> payload[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> checksum;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局 + 打包确保精确的内存布局</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(pop)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过偏移量访问成员</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> M&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">member_offset</span><span class=\"params\">(M T::*member)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_standard_layout_v&lt;T&gt;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(&amp;(<span class=\"built_in\">reinterpret_cast</span>&lt;T*&gt;(<span class=\"number\">0</span>)-&gt;*member));</span><br><span class=\"line\">&#125; <span class=\"comment\">// 只有标准布局类型才有确定的成员偏移量</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>POD 类型</p>\n<p>同时拥有以上两种类型的特性，是二者的交集。但现代 C++ 编码中应尽量避免使用这个概念。</p>\n</li>\n</ul>\n<hr>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://www.google.com/books/edition/C++_Core_Guidelines_Explained/ptnPEAAAQBAJ?hl=en&amp;gbpv=0\"><em>C++ Core Guidelines Explained: Best Practices for Modern C++</em></a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.788.comment.all.click&amp;vd_source=aec47f6b52af3774b903cb0d25607f6c\"><em>现代 C++ 教程</em></a></li>\n<li><a href=\"https://parallel101.github.io/cppguidebook/\"><em>小彭大典</em></a></li>\n</ul>\n","excerpt":"","more":"<h1>1. C++ 设计准则</h1>\n<h2 id=\"1-Philosophy\">1. Philosophy</h2>\n<h3 id=\"1-保持代码直观清晰\">1. 保持代码直观清晰</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Month <span class=\"title\">month</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>; <span class=\"comment\">// do</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">month</span><span class=\"params\">()</span></span>; <span class=\"comment\">// don&#x27;t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，前者是更好的写法，它的返回值是类型明确的，并且本身具有 const 限定。</p>\n<p> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; v.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(v[i] == val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        index = i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// bad</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find</span>(std::<span class=\"built_in\">begin</span>(v), std::<span class=\"built_in\">end</span>(v), val); <span class=\"comment\">// better</span></span><br></pre></td></tr></table></figure>\n<p>使用 STL 能使代码更加清晰简洁，不易出错。有一句现代 C++ 谚语：如果你还在显式地使用循环，那么你就没有真正理解 STL 算法。</p>\n<p> </p>\n<h3 id=\"2-遵循-ISO-Standard\">2. 遵循 ISO Standard</h3>\n<p>按照由国际标准化组织（ISO）制定并发布的《ISO/IEC 14882》C++ 标准来编写代码。</p>\n<p>这意味着尽量避免依赖各编译器厂商（如 GCC、MSVC、Clang）提供的额外语法或库扩展，以保证代码在不同环境下都能编译和运行。</p>\n<p>另外，需要注意 Undefined Behavior 和 Implementation‑Defined Behavior</p>\n<ul>\n<li>\n<p>Undefined Behavior</p>\n<p>指 C++ 标准未明确规定行为规范的代码操作，允许编译器自由处理。程序可能崩溃、产生错误结果、或看似正常运行实则存在隐患。程序应避免任何 UB。</p>\n<p><a href=\"https://parallel101.github.io/cppguidebook/undef/\"><em>未定义行为完整列表</em></a></p>\n</li>\n<li>\n<p>Implementation‑Defined Behavior</p>\n<p>指 C++ 标准允许编译器或运行时环境自由选择具体实现方式，但要求该行为必须被明确文档化。虽然具有平台依赖性，但结果是可预测的，由特定编译器的实现文档保证。</p>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"3-注释应写明意图\">3. 注释应写明意图</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; v : vec) &#123;...&#125; <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; v : vec) &#123;...&#125; <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::for_each(std::execution::par, vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">auto</span>&amp; v) &#123;...&#125;); <span class=\"comment\">// (3)</span></span><br></pre></td></tr></table></figure>\n<p>上述示例中，(1) 与 (2) 的区别在于前者不会修改容器中的元素。</p>\n<p>(3) 是使用并行的方式对容器中的每个元素执行一个操作。但是需要注意的小规模数据可能因线程调度开销导致性能下降，这种写法更适用于大规模数据。</p>\n<p>总之，注释应阐明意图，指出应该做什么。</p>\n<p> </p>\n<h3 id=\"4-保证程序的静态类型安全\">4. 保证程序的静态类型安全</h3>\n<p>C++ 是静态类型语言。即所有的变量或表达式的类型必须在编译时确定。静态类型安全要求编译器不仅知道其类型，还要能检测出类型相关的错误。C++ 并非完全类型安全，因此需要在编写代码时人工规避问题。</p>\n<p>以下是常见的类型安全的问题及规避方案：</p>\n<ul>\n<li>\n<p>联合体（Union）</p>\n<p>联合体允许不同类型共享同一内存空间，同一时间只能存储一个成员的值，可以达到节省内存的效果，<code>union</code> 的大小等于其最大成员的大小；</p>\n<p><code>union</code> 不记录当前活跃的成员，访问错误的成员会导致未定义行为。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">Data</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">float</span> f;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Data data;</span><br><span class=\"line\">data.i = <span class=\"number\">10</span>;</span><br><span class=\"line\">std::cout &lt;&lt; data.f &lt;&lt; std::endl; <span class=\"comment\">// 错误：此时通过 f 访问是未定义行为</span></span><br></pre></td></tr></table></figure>\n<p>在 C++11 之前，<code>union</code> 仅支持平凡类型。C++11 之后可以包含非平凡类型，但有严格限制。必须提供自定义构造函数，因为 <code>union</code> 的默认构造函数是 <code>delete</code> 状态。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">MyUnion</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    std::string s;  <span class=\"comment\">// 非平凡类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 编译器不会生成默认构造函数</span></span><br><span class=\"line\">    <span class=\"comment\">// MyUnion() = delete;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// MyUnion u;  // 错误,默认构造函数被删除</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>必须显式管理生命周期和追踪活跃成员，比如析构时需要识别出活跃成员，否则析构出错会有未定义行为。</p>\n<p>C++17 引入了 <code>std::variant</code>，它是一个类型安全的联合体。可以方便地存储非平凡类型，并且自动管理存储资源的生命周期，是 <code>union</code> 的上位替代。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::variant&lt;<span class=\"type\">int</span>, std::string&gt; v = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要知道类型进行访问</span></span><br><span class=\"line\">std::cout &lt;&lt; std::<span class=\"built_in\">get</span>&lt;std::string&gt;(v) &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类型安全的访问方式</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span>* str = std::<span class=\"built_in\">get_if</span>&lt;std::string&gt;(&amp;v)) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *str &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>类型转换</p>\n<p>显式类型转换（如 <code>static_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code>）可能引发错误或未定义行为</p>\n<blockquote>\n<p><code>dynamic_cast</code> 相对安全，有运行时类型检查。对于指针类型，转换失败会返回空指针；对于引用类型，转换失败会抛出 <code>std::bad_cast</code> 异常。</p>\n</blockquote>\n<p>而基于模板的泛型代码减少了对类型转换的需求，从某种程度上可以减少此类错误。</p>\n</li>\n<li>\n<p>数组退化</p>\n<p>C 风格数组在传递给函数时，会退化为指向其首元素的指针，丢失数组大小信息。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processArray</span><span class=\"params\">(<span class=\"type\">int</span> arr[])</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里 arr 实际上是指针，不是数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 输出指针大小(8/4字节)，无法获取原始数组大小</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size in function: &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr) &lt;&lt; std::endl; \t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C++20 提供的 <code>std::span</code> 是一个轻量级的视图，包含指针和大小信息，提供安全的数组访问，可以解决这个问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;span&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;array&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 std::span 接收数组，自动保持大小信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processWithSpan</span><span class=\"params\">(std::span&lt;<span class=\"type\">int</span>&gt; arr)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Span size: &quot;</span> &lt;&lt; arr.<span class=\"built_in\">size</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Span data: &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> value : arr) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 安全的索引访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); i++) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 子视图，同样安全</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.<span class=\"built_in\">size</span>() &gt;= <span class=\"number\">3</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> subspan = arr.<span class=\"built_in\">subspan</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 从索引1开始，取2个元素</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Subspan: &quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> val : subspan) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. C 风格数组，自动推导大小</span></span><br><span class=\"line\">    <span class=\"type\">int</span> cArray[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">processWithSpan</span>(cArray); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. std::array</span></span><br><span class=\"line\">    std::array&lt;<span class=\"type\">int</span>, 4&gt; stdArray = &#123; <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">processWithSpan</span>(stdArray);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. std::vector</span></span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; vec = &#123; <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">processWithSpan</span>(vec);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 动态数组，需要显式提供大小</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* dynamicArray = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">3</span>] &#123;<span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">processWithSpan</span>(std::<span class=\"built_in\">span</span>&lt;<span class=\"type\">int</span>&gt;(dynamicArray, <span class=\"number\">3</span>)); </span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] dynamicArray;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，动态数组的大小在运行时确定，编译期无法推导，所以需要显式提供大小。而 <code>std::vector</code> 因为它本身是包含 size 信息的完整类型，所以即使其 size 是在运行期确定的，也无需向 <code>std::span</code> 显式提供大小。</p>\n</li>\n<li>\n<p>窄化转换</p>\n<p>隐式转换可能导致数据丢失（如 <code>double</code> → <code>int</code> 截断小数）</p>\n<p>使用 <code>&#123;&#125;</code> 初始化（列表初始化）时，编译器会强制检查并拒绝窄化转换，帮助在编译期捕获此类错误。</p>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"5-优先编译期检查而非运行期检查\">5. 优先编译期检查而非运行期检查</h3>\n<p>所有能够在编译期进行的检查，都应当置于编译期完成。C++11 引入编译期断言 <code>static_assert</code> ，它接受一个常量表达式，在编译期验证条件，对条件不满足或者运行期才能确定的表达式产生编译错误。</p>\n<p>此外，类型特征库（type-traits library）允许开发者构建强大的条件检查：例如<code>static_assert(std::is_integral&lt;T&gt;::value)</code>。</p>\n<p> </p>\n<h3 id=\"6-无法在编译期检查的内容，应当能够在运行期进行检查\">6. 无法在编译期检查的内容，应当能够在运行期进行检查</h3>\n<p>借助 <code>dynamic_cast</code>，我们能够安全地在继承层次结构中向上、向下及横向转换类的指针和引用。如果转换失败，对于指针会返回 <code>nullptr</code>，对于引用则会抛出 <code>std::bad_cast</code> 异常</p>\n<p><code>dynamic_cast</code> 依赖于运行时类型信息（Run-Time Type Information, RTTI），而 RTTI 只对多态类型（即包含虚函数的类）可用。</p>\n<blockquote>\n<p>编译器在 <code>vtable</code> 中嵌入 <code>type_info</code> 对象，非多态类类型没有 <code>vtable</code>，因此没有存储类型信息的地方，<code>dynamic_cast</code> 通过查询对象的 <code>type_info</code> 来验证转换的合法性</p>\n</blockquote>\n<p>  </p>\n<h3 id=\"7-尽早捕获运行期错误\">7. 尽早捕获运行期错误</h3>\n<p>可采用多种对策消除运行时错误。比如检查指针、数组范围、类型转换等，避免错误的传播和扩散。</p>\n<p> </p>\n<h3 id=\"8-不要泄露任何资源\">8. 不要泄露任何资源</h3>\n<p>资源不仅指内存，还包括系统资源，如文件句柄、网络套接字、数据库连接、图形界面句柄、互斥锁等</p>\n<p>任何资源如果只申请不释放，都会随着程序的运行而不断累积。对于需要长时间运行的服务端程序或后台进程，即使是微小的泄露，最终也可能耗尽系统资源，导致程序崩溃或系统变得不稳定。</p>\n<p>处理资源的惯用方法是 RAII (Resource Acquisition Is Initialization)：</p>\n<ul>\n<li>将资源的生命周期与一个对象的生命周期绑定</li>\n<li>在对象的构造函数中获取资源</li>\n<li>在对象的析构函数中释放资源</li>\n<li>C++保证，当对象离开其作用域时（无论是正常离开，还是因为异常而离开），其析构函数一定会被自动调用，无需手动干预</li>\n</ul>\n<blockquote>\n<p>成员对象的析构函数在持有它的类析构时会自动调用，但它持有的资源是否需要手动释放，取决于该成员类型本身的实现</p>\n</blockquote>\n<p>RAII 应用示例：</p>\n<ul>\n<li>锁：如 <code>std::lock_guard</code> 或 <code>std::unique_lock</code>。在构造时锁定互斥量，在析构时自动解锁。这防止了因忘记解锁而导致的死锁</li>\n<li>智能指针：如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>。它们包装了原始指针，在析构时自动释放所指向的内存。这是现代C++取代 <code>new</code>/<code>delete</code> 的首选方式</li>\n<li>STL容器：如 <code>std::vector</code>, <code>std::string</code> 等。它们在析构时会自动清理其内部动态分配的所有元素和内存缓冲区，无需手动管理</li>\n</ul>\n<p> </p>\n<h3 id=\"9-不要浪费时间和空间\">9. 不要浪费时间和空间</h3>\n<p>需要有意识地避免不必要的时间和空间开销。比如以下例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lower</span><span class=\"params\">(std::string s)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">unsigned</span> <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= std::<span class=\"built_in\">strlen</span>(s.<span class=\"built_in\">data</span>()); ++i) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s[i] = std::<span class=\"built_in\">tolower</span>(s[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数想将字符串 <code>s</code> 转换为小写字符，但有以下问题：</p>\n<ul>\n<li>时间开销：<code>std::strlen(s.data())</code> 在每次循环迭代时都会被调用。<code>strlen</code> 是一个 O(n) 复杂度的函数，它需要遍历整个字符串直到找到空终止符 <code>\\0</code>。这导致一个原本是 O(n) 的循环变成了 O(n²)，对于长字符串会造成巨大的性能浪费</li>\n<li>传参错误：应传引用，传值并没有改动 <code>s</code>，并造成了额外的拷贝</li>\n</ul>\n<p>使用 <code>std::transform</code> 可以解决上述问题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">transform</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>(), s.<span class=\"built_in\">begin</span>(),</span><br><span class=\"line\">              [](<span class=\"type\">char</span> c) &#123; <span class=\"keyword\">return</span> std::<span class=\"built_in\">tolower</span>(c); &#125;);</span><br></pre></td></tr></table></figure>\n<p>下一个例子是抑制移动语义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">S</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::string s_;</span><br><span class=\"line\">    <span class=\"built_in\">S</span>(std::string s): <span class=\"built_in\">s_</span>(s) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">S</span>(<span class=\"type\">const</span> S&amp; rhs): <span class=\"built_in\">s_</span>(rhs.s_) &#123;&#125;</span><br><span class=\"line\">    S&amp; <span class=\"keyword\">operator</span> = (<span class=\"type\">const</span> S&amp; rhs) &#123; s_ = rhs.s_; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">S s1;</span><br><span class=\"line\">S s2 = std::<span class=\"built_in\">move</span>(s1); <span class=\"comment\">// 这里执行的是拷贝，而非从 s1.s_ 移动</span></span><br></pre></td></tr></table></figure>\n<p>C++11 引入了移动语义，通过移动构造函数和移动赋值运算符实现。它将资源从一个临时对象（通常是右值）移动过来，而不是复制，成本低廉。</p>\n<p>但是在这个例子中，用户手动定义了拷贝构造函数和拷贝赋值运算符。根据C++标准规则，一旦用户显式定义了这些拷贝操作，编译器就不会自动生成默认的移动操作（移动构造函数和移动赋值运算符）。</p>\n<blockquote>\n<p>但可以通过<code>= default</code>显式要求编译器生成移动操作</p>\n</blockquote>\n<p>因此，在代码 <code>S s2 = std::move(s1);</code> 中，<code>std::move(s1)</code> 本意是将 <code>s1</code> 转换为一个右值，期望触发移动操作。但由于 <code>S</code> 没有移动构造函数，编译器只能退而求其次，调用拷贝构造函数。这里的 <code>std::move</code> 实际上没有起到任何加速作用，反而产生了昂贵的拷贝开销。</p>\n<p>现代C++的最佳实践是“零规则”(Rule of Zero)：尽量避免手动定义拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符和析构函数。让编译器为你生成所有这些默认操作。在无需直接管理资源的大多数情况下，编译器生成的都是正确且最优的。</p>\n<p>如果类需要直接管理资源，确实需要自定义这些操作，那么应遵循 “五规则”(Rule of Five)：如果需要自定义其中任何一个，那么很可能需要同时自定义所有五个（拷贝构造、移动构造、拷贝赋值、移动赋值、析构），并正确地实现它们。</p>\n<p> </p>\n<h3 id=\"10-优先使用不可变数据而非可变数据\">10. 优先使用不可变数据而非可变数据</h3>\n<p>不可变数据（常量）有以下优势：</p>\n<ul>\n<li>固化状态流转路径，降低代码复杂度</li>\n<li>利于编译期优化：包括常量传播、公共子表达式消除、死代码删除等编译优化技术</li>\n<li>并发安全</li>\n</ul>\n<p> </p>\n<h3 id=\"11-封装杂乱的构造，而非将其散布在代码中\">11. 封装杂乱的构造，而非将其散布在代码中</h3>\n<p>如果有可能，尽量不要自己实现复杂易错的底层代码，优先考虑类似 STL 这样的成熟代码库。</p>\n<p>如果找不到现成的高级库来替代必要的复杂逻辑，尽量将混乱、易变的细节隐藏在简洁的接口之中。</p>\n<p> </p>\n<h3 id=\"12-根据需要使用辅助工具\">12. 根据需要使用辅助工具</h3>\n<p>使用如静态分析工具、并发分析工具、测试工具等辅助工具，可有效提高代码的正确性，可移植性和健壮性。</p>\n<p>不同的编译器（如 GCC, Clang, MSVC）对 C++ 标准的实现和理解略有不同，使用多种 C++ 编译器来编译代码，也是很好的验证代码的方式。</p>\n<p> </p>\n<h3 id=\"13-根据需要使用支持库\">13. 根据需要使用支持库</h3>\n<p>根据需要使用高质量外部库可避免重复造轮子，提升开发效率和代码质量。</p>\n<p> </p>\n<h2 id=\"2-Interfaces\">2. Interfaces</h2>\n<h3 id=\"1-避免使用非-const-的全局变量\">1. 避免使用非 <code>const</code> 的全局变量</h3>\n<p>全局变量向函数内部注入了一个隐藏的依赖项，并且这个依赖项并非接口的一部分，容易出错，并且存在并发安全问题。</p>\n<p> </p>\n<h3 id=\"2-谨慎使用单例\">2. 谨慎使用单例</h3>\n<p>从本质上讲，单例也是一种全局变量。虽然它在很多场景下是有必要的，但我们在使用时也需要考虑以下问题：</p>\n<ul>\n<li>谁负责销毁单例？</li>\n<li>应该允许单例派生吗？</li>\n<li>如何以线程安全的方式初始化单例？</li>\n<li>当单例相互依赖且位于不同的编译单元时，它们的初始化顺序是怎样的？（静态初始化顺序问题）</li>\n</ul>\n<p> </p>\n<h3 id=\"3-书写好的接口\">3. 书写好的接口</h3>\n<p>好的接口应遵循以下规则：</p>\n<ul>\n<li>明确</li>\n<li>强类型</li>\n<li>尽可能少的参数</li>\n<li>避免相邻的、不相关的同类型参数</li>\n</ul>\n<p>结构体传参是一种好的写法，将复杂的参数列表封装为一个 <code>struct</code>，既很好地满足了上述规则，还使得接口的调整变得容易。如果接口需要新的参数，只需要在 <code>struct</code> 新增一个给出默认值的参数即可，所有的老代码依然正常调用，而无需到处修改。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Light</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    vec3 color;</span><br><span class=\"line\">    <span class=\"type\">int</span> type;</span><br><span class=\"line\">    <span class=\"type\">double</span> brightNess = <span class=\"number\">.0</span>; <span class=\"comment\">// 令 brightNess 默认为 0</span></span><br><span class=\"line\">    vec3 loc;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>而所有的老代码依然可以正常调用，未指定的 <code>brightNess</code> 会具有默认值 <code>.0</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">buildLightPass</span><span class=\"params\">(&#123;.name = <span class=\"string\">&quot;Light1&quot;</span>, .color = &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, .type = <span class=\"number\">1</span>, .loc = &#123;<span class=\"number\">.0</span>, <span class=\"number\">.0</span>, <span class=\"number\">.0</span>&#125;&#125;)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>同理，如果有必要的话，返回值也可以定义为结构体。</p>\n<p>对于返回值可能为空的的函数，或许空值语义是一种更好的写法。C++17 引入了 <code>std::optional</code>，形如 <code>std::optional&lt;T&gt;</code> 的类型有两种可能的状态：为空<code>nullopt</code> 和有值。这是一种语义更加明确的设计。</p>\n<p> </p>\n<h3 id=\"4-不要以指针的方式传递数组\">4. 不要以指针的方式传递数组</h3>\n<p>当我们将数组传递给一个入参是指针的函数时，数组会自动退化为其首元素的指针，所以往往还需要传递数组的大小。</p>\n<p>这是一种容易出错的写法，如果有可能的话使用 <code>std::vector</code> 作为函数的入参更好，但如果场景中为了满足入参不得不拷贝数据，从数组创建 <code>std::vector</code>，<code>std::span</code> 将是更好的选择。</p>\n<p> </p>\n<h3 id=\"5-为了稳定的-ABI，可考虑-Pimpl\">5. 为了稳定的 ABI，可考虑 Pimpl</h3>\n<p><code>Pimpl</code>（Pointer to Implementation）是 C++ 中的一种编译时封装技术，通过将类的实现细节隐藏在一个指向实现类的指针后面来减少编译依赖和提高封装性。</p>\n<blockquote>\n<p>ABI 是二进制程序组件之间的接口，它定义了：</p>\n<ul>\n<li>\n<p>内存布局：类/结构体的大小、成员偏移量</p>\n</li>\n<li>\n<p>函数调用约定：参数传递方式、栈清理责任</p>\n</li>\n<li>\n<p>名称修饰：C++ 函数名在二进制中的表示方式</p>\n</li>\n<li>\n<p>异常处理机制：异常如何抛出和捕获</p>\n</li>\n<li>\n<p>虚函数表布局：多态类的运行时结构</p>\n</li>\n</ul>\n</blockquote>\n<p>基本结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">publicMethod</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Impl</span>;  <span class=\"comment\">// 前向声明</span></span><br><span class=\"line\">    std::unique_ptr&lt;Impl&gt; m_pImpl;  <span class=\"comment\">// 指向实现的指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Pimpl 主要优势有两个：</p>\n<ul>\n<li>分离定义，加速编译（修改了具体实现 <code>Impl</code>，只需要重新编译 <code>MyClass.cpp</code>）</li>\n<li>可以保持 ABI 的稳定性，方便发布库更新和插件热装载</li>\n</ul>\n<p>其代价是每次访问实现都有一次指针间接寻址，有极轻微的性能损失，代码结构更加复杂。适用于大型类（有很多的私有成员和方法），库开发（需要保持二进制的兼容性），编译时间敏感等场景。</p>\n<p> </p>\n<h2 id=\"3-Functions\">3. Functions</h2>\n<h3 id=\"1-函数定义\">1. 函数定义</h3>\n<p>定义一个函数首先需要考虑如何命名，好的函数命名并无铁律，不过这里仍有三条实用的建议：</p>\n<ul>\n<li>取有意义的名字</li>\n<li>函数应该执行单个逻辑操作</li>\n<li>保持函数简洁</li>\n</ul>\n<p> </p>\n<p>如果一个函数在编译期求值，应将其声明为 <code>constexpr</code>：</p>\n<ul>\n<li>\n<p>当在一个常量表达式中调用 <code>constexpr</code> 函数，或者将其结果赋值一个 <code>constexpr</code> 变量时，它会在编译期执行</p>\n</li>\n<li>\n<p><code>constexpr</code> 函数并非只能在编译期执行，当传递给它的参数是运行时才能确定的，或者没有强制要求结果是常量，那么它将退化成在运行时执行</p>\n</li>\n<li>\n<p>当函数在编译期执行完成后，计算结果作为一个普通的字面常量存储在 ROM(Read Only Memory) 中，通常对应可执行文件中的 <code>.rodata</code> 段（只读数据段）</p>\n</li>\n<li>\n<p><code>constexpr</code> 函数是隐式内联的，这意味着可以（并且通常应该将 <code>constexpr</code> 函数的定义写在头文件中）</p>\n<blockquote>\n<p>如果是普通函数，那么编译器并不需要知道函数的具体实现，因为链接器 (Linker) 稍后会负责找到它。</p>\n<p>但如果是 <code>constexpr</code> 函数，函数的完整定义必对当前编译的文件可见。最简单直接的方式就是将完整定义写在头文件里（也有一些其他实现方法：如 C++ 20 Modules，Untiy Build[单编译单元构建]等）</p>\n<p>引申：如果是一个普通函数的定义写在了头文件里，是一种禁忌：</p>\n<ul>\n<li>\n<p>当两个 <code>.cpp</code> 源文件都包含这个头文件时，将分别生成两个同名符号，链接器在链接时无法区分，于是报错<code>Multiple definition of 'add'</code>（重定义错误）</p>\n</li>\n<li>\n<p>这违背了 ODR（One Definition Rule，单一定义规则）：一个非内联函数在整个程序中只能有一个定义</p>\n</li>\n<li>\n<p><code>inline</code> 现在真正的作用是让多个翻译单元共享同一个定义，突破单一定义规则，可以解决这个问题</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><code>constexpr</code> 函数天然线程安全</p>\n</li>\n</ul>\n<p> </p>\n<p>如果函数不会抛出异常，应将其声明为 <code>noexcept</code></p>\n<p> </p>\n<h1>2. C++ 基础</h1>\n<h2 id=\"1-平凡类型（Trivial-Type）\">1. 平凡类型（Trivial Type）</h2>\n<p>C++11 引入平凡类型的概念，用于描述“没有副作用的构造/析构/赋值等操作”的类型，一个类型是平凡类型当且仅当它满足以下所有条件：</p>\n<ul>\n<li>无用户定义的构造函数</li>\n<li>无用户定义的析构函数</li>\n<li>无用户定义的拷贝/移动构造函数</li>\n<li>无用户定义的拷贝/移动赋值操作符</li>\n<li>无虚函数，无虚基类</li>\n<li>所有非静态成员和基类都是平凡的</li>\n</ul>\n<p>可使用 <code>std::is_trivial</code> 进行判别。</p>\n<p>POD 类型（Plain Old Data）相比于平凡类型是一个更严格、更古老的限制。在平凡类型的基础上还有标准布局（Standard Layout）的要求。</p>\n<p>标准布局类型满足以下条件：</p>\n<ul>\n<li>所有非静态成员具有相同的访问控制</li>\n<li>无虚函数，无虚基类</li>\n<li>没有引用类型的非静态数据成员</li>\n<li>所有非静态数据成员都是标准布局类型</li>\n<li>所有基类都是标准布局类型</li>\n<li>满足以下继承条件之一：\n<ul>\n<li>没有基类</li>\n<li>只有一个基类且没有非静态数据成员</li>\n<li>基类和派生类中不能同时有非静态数据成员</li>\n</ul>\n</li>\n</ul>\n<p>可使用 <code>std::is_standard_layout_v</code> 判别是否是标准布局类型。</p>\n<p>POD 类型也有 <code>std::is_pod</code> 这样的判断方法，但是该方法已经在 C++20 中被移除，不推荐使用。可通过 <code>std::is_standard_layout_v</code> 和 <code>std::is_trivial</code> 的组合来达到相同的目的。即：</p>\n<blockquote>\n<p>POD = Trivial &amp;&amp; Standard Layout</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checkTypeProperties</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Type: &quot;</span> &lt;&lt; <span class=\"built_in\">typeid</span>(T).<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is trivial: &quot;</span> &lt;&lt; std::is_trivial_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is standard layout: &quot;</span> &lt;&lt; std::is_standard_layout_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Is POD: &quot;</span> &lt;&lt; std::is_pod_v&lt;T&gt; &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;---\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POD类型</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">POD_Example</span> </span><br><span class=\"line\">&#123;        </span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">char</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 平凡但非POD</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialNonPOD1</span> </span><br><span class=\"line\">&#123;     </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> public_member;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> private_member;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承破坏标准布局</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialNonPOD2</span> : POD_Example </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"type\">int</span> additional_member;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;POD_Example&gt;();</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;TrivialNonPOD1&gt;();</span><br><span class=\"line\">    <span class=\"built_in\">checkTypeProperties</span>&lt;TrivialNonPOD2&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>\n<p>平凡类型</p>\n<p>其核心特性在于可以使用 <code>memcpy</code> 等低级内存操作进行复制，而不需要逐个调用拷贝构造函数，在需要高效移动和复制时很有用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 高效内存复制</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">trivial_copy</span><span class=\"params\">(<span class=\"type\">const</span> T* src, T* dest, <span class=\"type\">size_t</span> count)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_trivial_v&lt;T&gt;, </span><br><span class=\"line\">    <span class=\"string\">&quot;Type must be trivial for memcpy operations&quot;</span>);</span><br><span class=\"line\">    std::<span class=\"built_in\">memcpy</span>(dest, src, count * <span class=\"built_in\">sizeof</span>(T));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 序列化/反序列化</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrivialData</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">double</span> value;</span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">32</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">serialize_trivial</span><span class=\"params\">(<span class=\"type\">const</span> TrivialData&amp; data, <span class=\"type\">char</span>* buffer)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 安全地直接复制内存</span></span><br><span class=\"line\">    std::<span class=\"built_in\">memcpy</span>(buffer, &amp;data, <span class=\"built_in\">sizeof</span>(TrivialData));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象池和内存管理</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_trivial_v&lt;T&gt;, <span class=\"string\">&quot;ObjectPool requires trivial types for efficient reuse&quot;</span>);</span><br><span class=\"line\">    std::vector&lt;T&gt; pool;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">T* <span class=\"title\">allocate</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以安全地重用内存而不调用析构函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;pool.<span class=\"built_in\">emplace_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>标准布局类型</p>\n<p>其核心特性是确定性的内存布局，并与 C 语言兼容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 与C语言互操作</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">CStruct</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        <span class=\"type\">double</span> y;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process_c_struct</span><span class=\"params\">(CStruct* data)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CompatibleCppStruct</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">double</span> y;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局，可以与C结构体安全互操作</span></span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(std::is_standard_layout_v&lt;CompatibleCppStruct&gt;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 硬件寄存器映射</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">DeviceRegisterMap</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> control;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> status;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> data;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局确保成员顺序与硬件寄存器一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 网络协议数据包</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(push, 1)</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">NetworkPacket</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> header;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> sequence;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> payload[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> checksum;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 标准布局 + 打包确保精确的内存布局</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(pop)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过偏移量访问成员</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> M&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">member_offset</span><span class=\"params\">(M T::*member)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static_assert</span>(std::is_standard_layout_v&lt;T&gt;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">size_t</span>&gt;(&amp;(<span class=\"built_in\">reinterpret_cast</span>&lt;T*&gt;(<span class=\"number\">0</span>)-&gt;*member));</span><br><span class=\"line\">&#125; <span class=\"comment\">// 只有标准布局类型才有确定的成员偏移量</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>POD 类型</p>\n<p>同时拥有以上两种类型的特性，是二者的交集。但现代 C++ 编码中应尽量避免使用这个概念。</p>\n</li>\n</ul>\n<hr>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://www.google.com/books/edition/C++_Core_Guidelines_Explained/ptnPEAAAQBAJ?hl=en&amp;gbpv=0\"><em>C++ Core Guidelines Explained: Best Practices for Modern C++</em></a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.788.comment.all.click&amp;vd_source=aec47f6b52af3774b903cb0d25607f6c\"><em>现代 C++ 教程</em></a></li>\n<li><a href=\"https://parallel101.github.io/cppguidebook/\"><em>小彭大典</em></a></li>\n</ul>\n","path":"2025/11/09/C-General/","permalink":"https://zweireverberate.space/2025/11/09/C-General/","tags":[{"name":"C++","_id":"cmhrudxl400015kcn8x15hevj","slug":"C","path":"tags/C/","permalink":"https://zweireverberate.space/tags/C/","length":1}],"categories":[],"prev":{"title":"现代图形 API","date":"2025-11-30T14:38:03.000Z","summary":"现代图形 API 综述","slug":"现代图形-API","published":true,"updated":"2025-12-10T15:22:05.525Z","_id":"cmiltx92h000040cn51xc2jf4","layout":"post","photos":[],"excerpt":"","path":"2025/11/30/现代图形-API/","permalink":"https://zweireverberate.space/2025/11/30/%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%BD%A2-API/","__post":true},"next":{"title":"Coding Problems","date":"2025-10-26T12:05:21.000Z","summary":"算法练习题","slug":"Coding-Problems","published":true,"updated":"2025-11-02T08:11:00.332Z","_id":"cmh7o11j60000r4cn5skl1af9","layout":"post","photos":[],"excerpt":"","path":"2025/10/26/Coding-Problems/","permalink":"https://zweireverberate.space/2025/10/26/Coding-Problems/","__post":true},"__post":true}