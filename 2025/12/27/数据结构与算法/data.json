{"title":"数据结构与算法","date":"2025-12-27T13:39:50.000Z","toc":true,"summary":"数据结构与算法综述","source":"_posts/数据结构与算法.md","raw":"---\ntitle: 数据结构与算法\ndate: 2025-12-27 21:39:50\ntags: Algorithm\ntoc: true\nsummary: \"数据结构与算法综述\"\n---\n\n# 1. 排序\n\n排序算法（Sorting Algorithm）是一种将一组特定的数据按某种顺序进行排列的算法。\n\n除了时空复杂度，我们通常还关心排序算法的稳定性，稳定的排序算法不改变原始数据相等元素的顺序。\n\n### 1. 归并排序\n\n归并排序（Merge Sort）基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均的情况下均为 $\\mathbf{O}(n\\log{n})$，空间复杂度为 $\\mathbf{O}(n)$，是一个稳定的排序算法。\n\n归并排序的核心是合并过程，假设一个 `std::vector` 已经被划分为有序的两个部分：$[left, mid)$ 和 $[mid, right)$，那我们的合并逻辑可以是：\n\n```c++\ntemplate<typename T>\nvoid merge(std::vector<T>& arr, std::vector<T>& tmp, size_t left, size_t mid, size_t right)\n{\n\t// 合并两个有序区间 [left, mid) 和 [mid, right)\n\tsize_t i = left, j = mid, tmpIdx = left;\n\twhile (i < mid && j < right)\n\t{\n\t\tif (arr[i] <= arr[j]) // 保持稳定性\n\t\t{\n\t\t\ttmp[tmpIdx++] = std::move(arr[i++]); // 移动赋值，避免拷贝\n\t\t}\n\t\telse\n\t\t{ \n\t\t\ttmp[tmpIdx++] = std::move(arr[j++]);\n\t\t}\n\t}\n\twhile (i < mid)\n\t{\n\t\ttmp[tmpIdx++] = std::move(arr[i++]);\n\t}\n\twhile (j < right)\n\t{\n\t\ttmp[tmpIdx++] = std::move(arr[j++]);\n\t}\n\t// 将合并结果复制回原数组\n\tstd::move(tmp.begin() + left, tmp.begin() + right, arr.begin() + left);\n}\n\n```\n\n对于两份正序数据，合并它们只需要同时遍历二者，结果中加入当前较小元素。当其中一份数据遍历完成后，将剩余的另一份数据追加在结果尾部。\n\n>上述代码中两种 `std::move` 的用法并不一样，前者将左值转换为右值引用，以便调用移动构造函数避免拷贝。后者则是将源范围的元素移动到目标范围。\n\n而归并排序的过程可以看作是将源数据划分为两部分，对这两部分分别执行归并排序，再合并的过程：\n\n```c++\ntemplate<typename T>\nvoid mergeSortImpl(std::vector<T>& arr, std::vector<T>& tmp, size_t left, size_t right) \n{\n\tif (right - left <= 1)\n\t{\n\t\treturn;\n\t}\n\n\tsize_t mid = left + (right - left) / 2;\n\tmergeSortImpl(arr, tmp, left, mid);\n\tmergeSortImpl(arr, tmp, mid, right);\n\n\tmerge(arr, tmp, left, mid, right);\n}\n\ntemplate<typename T>\nvoid mergeSort(std::vector<T>& arr) \n{\n\tif (arr.size() <= 1)\n\t{\n\t\treturn;\n\t}\n\n\t// 预分配临时数组，避免递归中反复分配\n\tstd::vector<T> temp(arr.size());\n\tmergeSortImpl(arr, temp, 0, arr.size());\n}\n```\n\n二路归并是最常见的写法，如果数据规模巨大，完全可以结合并行技术使用多路归并。\n\n---\n\n**Reference**\n\n- [OI Wiki](https://oi-wiki.org/)\n\n  ","slug":"数据结构与算法","published":true,"updated":"2026-01-04T10:46:54.993Z","_id":"cmjyd9nxc0000occnht9t22d2","comments":true,"layout":"post","photos":[],"html":"<h1>1. 排序</h1>\n<p>排序算法（Sorting Algorithm）是一种将一组特定的数据按某种顺序进行排列的算法。</p>\n<p>除了时空复杂度，我们通常还关心排序算法的稳定性，稳定的排序算法不改变原始数据相等元素的顺序。</p>\n<h3 id=\"1-归并排序\">1. 归并排序</h3>\n<p>归并排序（Merge Sort）基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均的情况下均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{O}(n\\log{n})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span><span class=\"mclose\">)</span></span></span></span>，空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{O}(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，是一个稳定的排序算法。</p>\n<p>归并排序的核心是合并过程，假设一个 <code>std::vector</code> 已经被划分为有序的两个部分：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator=\"true\">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[left, mid)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">t</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">mi</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator=\"true\">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[mid, right)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">mi</span><span class=\"mord mathnormal\">d</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span>，那我们的合并逻辑可以是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(std::vector&lt;T&gt;&amp; arr, std::vector&lt;T&gt;&amp; tmp, <span class=\"type\">size_t</span> left, <span class=\"type\">size_t</span> mid, <span class=\"type\">size_t</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 合并两个有序区间 [left, mid) 和 [mid, right)</span></span><br><span class=\"line\">\t<span class=\"type\">size_t</span> i = left, j = mid, tmpIdx = left;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; mid &amp;&amp; j &lt; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[i] &lt;= arr[j]) <span class=\"comment\">// 保持稳定性</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp[tmpIdx++] = std::<span class=\"built_in\">move</span>(arr[i++]); <span class=\"comment\">// 移动赋值，避免拷贝</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\ttmp[tmpIdx++] = std::<span class=\"built_in\">move</span>(arr[j++]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; mid)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp[tmpIdx++] = std::<span class=\"built_in\">move</span>(arr[i++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp[tmpIdx++] = std::<span class=\"built_in\">move</span>(arr[j++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 将合并结果复制回原数组</span></span><br><span class=\"line\">\tstd::<span class=\"built_in\">move</span>(tmp.<span class=\"built_in\">begin</span>() + left, tmp.<span class=\"built_in\">begin</span>() + right, arr.<span class=\"built_in\">begin</span>() + left);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对于两份正序数据，合并它们只需要同时遍历二者，结果中加入当前较小元素。当其中一份数据遍历完成后，将剩余的另一份数据追加在结果尾部。</p>\n<blockquote>\n<p>上述代码中两种 <code>std::move</code> 的用法并不一样，前者将左值转换为右值引用，以便调用移动构造函数避免拷贝。后者则是将源范围的元素移动到目标范围。</p>\n</blockquote>\n<p>而归并排序的过程可以看作是将源数据划分为两部分，对这两部分分别执行归并排序，再合并的过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSortImpl</span><span class=\"params\">(std::vector&lt;T&gt;&amp; arr, std::vector&lt;T&gt;&amp; tmp, <span class=\"type\">size_t</span> left, <span class=\"type\">size_t</span> right)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (right - left &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">size_t</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSortImpl</span>(arr, tmp, left, mid);</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSortImpl</span>(arr, tmp, mid, right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(arr, tmp, left, mid, right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(std::vector&lt;T&gt;&amp; arr)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arr.<span class=\"built_in\">size</span>() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 预分配临时数组，避免递归中反复分配</span></span><br><span class=\"line\">\t<span class=\"function\">std::vector&lt;T&gt; <span class=\"title\">temp</span><span class=\"params\">(arr.size())</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSortImpl</span>(arr, temp, <span class=\"number\">0</span>, arr.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二路归并是最常见的写法，如果数据规模巨大，完全可以结合并行技术使用多路归并。</p>\n<hr>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://oi-wiki.org/\">OI Wiki</a></li>\n</ul>\n","excerpt":"","more":"<h1>1. 排序</h1>\n<p>排序算法（Sorting Algorithm）是一种将一组特定的数据按某种顺序进行排列的算法。</p>\n<p>除了时空复杂度，我们通常还关心排序算法的稳定性，稳定的排序算法不改变原始数据相等元素的顺序。</p>\n<h3 id=\"1-归并排序\">1. 归并排序</h3>\n<p>归并排序（Merge Sort）基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均的情况下均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{O}(n\\log{n})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span><span class=\"mclose\">)</span></span></span></span>，空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{O}(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，是一个稳定的排序算法。</p>\n<p>归并排序的核心是合并过程，假设一个 <code>std::vector</code> 已经被划分为有序的两个部分：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator=\"true\">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[left, mid)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">t</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">mi</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator=\"true\">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[mid, right)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">mi</span><span class=\"mord mathnormal\">d</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span>，那我们的合并逻辑可以是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(std::vector&lt;T&gt;&amp; arr, std::vector&lt;T&gt;&amp; tmp, <span class=\"type\">size_t</span> left, <span class=\"type\">size_t</span> mid, <span class=\"type\">size_t</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 合并两个有序区间 [left, mid) 和 [mid, right)</span></span><br><span class=\"line\">\t<span class=\"type\">size_t</span> i = left, j = mid, tmpIdx = left;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; mid &amp;&amp; j &lt; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[i] &lt;= arr[j]) <span class=\"comment\">// 保持稳定性</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp[tmpIdx++] = std::<span class=\"built_in\">move</span>(arr[i++]); <span class=\"comment\">// 移动赋值，避免拷贝</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\ttmp[tmpIdx++] = std::<span class=\"built_in\">move</span>(arr[j++]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; mid)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp[tmpIdx++] = std::<span class=\"built_in\">move</span>(arr[i++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp[tmpIdx++] = std::<span class=\"built_in\">move</span>(arr[j++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 将合并结果复制回原数组</span></span><br><span class=\"line\">\tstd::<span class=\"built_in\">move</span>(tmp.<span class=\"built_in\">begin</span>() + left, tmp.<span class=\"built_in\">begin</span>() + right, arr.<span class=\"built_in\">begin</span>() + left);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对于两份正序数据，合并它们只需要同时遍历二者，结果中加入当前较小元素。当其中一份数据遍历完成后，将剩余的另一份数据追加在结果尾部。</p>\n<blockquote>\n<p>上述代码中两种 <code>std::move</code> 的用法并不一样，前者将左值转换为右值引用，以便调用移动构造函数避免拷贝。后者则是将源范围的元素移动到目标范围。</p>\n</blockquote>\n<p>而归并排序的过程可以看作是将源数据划分为两部分，对这两部分分别执行归并排序，再合并的过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSortImpl</span><span class=\"params\">(std::vector&lt;T&gt;&amp; arr, std::vector&lt;T&gt;&amp; tmp, <span class=\"type\">size_t</span> left, <span class=\"type\">size_t</span> right)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (right - left &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">size_t</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSortImpl</span>(arr, tmp, left, mid);</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSortImpl</span>(arr, tmp, mid, right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(arr, tmp, left, mid, right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(std::vector&lt;T&gt;&amp; arr)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arr.<span class=\"built_in\">size</span>() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 预分配临时数组，避免递归中反复分配</span></span><br><span class=\"line\">\t<span class=\"function\">std::vector&lt;T&gt; <span class=\"title\">temp</span><span class=\"params\">(arr.size())</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSortImpl</span>(arr, temp, <span class=\"number\">0</span>, arr.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二路归并是最常见的写法，如果数据规模巨大，完全可以结合并行技术使用多路归并。</p>\n<hr>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://oi-wiki.org/\">OI Wiki</a></li>\n</ul>\n","path":"2025/12/27/数据结构与算法/","permalink":"https://zweireverberate.space/2025/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","tags":[{"name":"Algorithm","_id":"cmh7o11jb0001r4cn6kknbc7r","slug":"Algorithm","path":"tags/Algorithm/","permalink":"https://zweireverberate.space/tags/Algorithm/","length":2}],"categories":[],"prev":{"title":"素影微行","date":"2989-06-04T06:36:24.000Z","summary":"随笔","slug":"素影微行","published":true,"updated":"2025-07-14T15:13:50.317Z","_id":"cmefcsga500017gcn3f043goh","layout":"post","photos":[],"excerpt":"","path":"2989/06/04/素影微行/","permalink":"https://zweireverberate.space/2989/06/04/%E7%B4%A0%E5%BD%B1%E5%BE%AE%E8%A1%8C/","__post":true},"next":{"title":"现代图形 API","date":"2025-11-30T14:38:03.000Z","summary":"现代图形 API 综述","slug":"现代图形-API","published":true,"updated":"2025-12-11T14:52:01.638Z","_id":"cmiltx92h000040cn51xc2jf4","layout":"post","photos":[],"excerpt":"","path":"2025/11/30/现代图形-API/","permalink":"https://zweireverberate.space/2025/11/30/%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%BD%A2-API/","__post":true},"__post":true}