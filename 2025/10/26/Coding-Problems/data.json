{"title":"Coding Problems","date":"2025-10-26T12:05:21.000Z","toc":true,"summary":"算法练习题","source":"_posts/Coding-Problems.md","raw":"---\ntitle: Coding Problems\ndate: 2025-10-26 20:05:21\ntags: Algorithm\ntoc: true\nsummary: \"算法练习题\"\n---\n\n# [1. 两数之和](https://leetcode.cn/problems/two-sum/description/)\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n\n你可以按任意顺序返回答案。\n\n**示例 1：**\n\n```\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,3], target = 6\n输出：[0,1]\n```\n\n**提示：**\n\n- `2 <= nums.length <= 104`\n- `-109 <= nums[i] <= 109`\n- `-109 <= target <= 109`\n- **只会存在一个有效答案**\n\n暴力方法，对于每一个 num，和 nums 中其他所有 num 计算 target 即可。\n\n```c++\nclass Solution \n{\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) \n    {\n        for(int i = 0; i < nums.size()-1; ++i)\n        {\n            for(int j = i + 1; j < nums.size(); ++j)\n            {\n                if(nums[i] + nums[j] == target)\n                {\n                    return {i, j};\n                }\n            }\n        }\n        return {};\n    }\n};\n```\n\n更高效率的方式是先将 nums 记录到一个哈希表中，遍历 num 时只需要在哈希表中查询 target - num。\n\n```c++\nclass Solution \n{\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) \n    {\n        std::unordered_map<int, int> resMap;\n        for(int i = 0; i < nums.size(); ++i)\n        {\n            resMap[nums[i]] = i;\n        }\n\n        for(int i = 0; i < nums.size(); ++i)\n        {\n            int val = target - nums[i];\n            auto iter = resMap.find(val);\n            if(iter != resMap.end() && i != iter->second)\n            {\n                return {i, iter->second};\n            }\n        }\n\n        return {};\n    }\n};\n```\n\n以上写法的不足之处在于构建哈希表时额外多了一次遍历，实际上可以边计算结果边构建，在遍历到其中一个 num 时不需要急于得出结果，只将其放入哈希表，因为后续一定会遍历到 target - num。\n\n\n\n```c++\nclass Solution \n{\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) \n    {\n       std::unordered_map<int, int> resMap;\n       for(int i = 0; i < nums.size(); ++i)\n       {\n            if(resMap.count(target - nums[i]))\n            {\n                return {i, resMap[target - nums[i]]};\n            }\n            else\n            {\n                resMap[nums[i]] = i;\n            }\n       }\n       return {};\n    }\n};\n```\n\n# [2. 反转链表](https://leetcode.cn/problems/UHnkqh/)\n\n给定单链表的头节点 `head` ，请反转链表，并返回反转后的链表的头节点。\n\n**示例 1：**\n\n```\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n```\n\n**示例 2：**\n\n```\n输入：head = [1,2]\n输出：[2,1]\n```\n\n**示例 3：**\n\n```\n输入：head = []\n输出：[]\n```\n\n**提示：**\n\n- 链表中节点的数目范围是 `[0, 5000]`\n- `-5000 <= Node.val <= 5000`\n\n链表结构：\n\n```c++\nstruct ListNode \n{\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n```\n\n定义一个 curNode 和一个指向 curNode 下一个节点的 nextNode，只需要将 nextNode 的 next 指针反向指向 curNode 即可。\n\n```c++\nclass Solution \n{\npublic:\n    ListNode* reverseList(ListNode* head) \n    {\n        if(!head)\n        {\n            return nullptr;\n        }\n\n        ListNode* curNode = head;\n        ListNode* nextNode = curNode->next;\n\n        while(nextNode)\n        {\n            if(curNode == head)\n            {\n                curNode->next = nullptr;\n            }\n\n            ListNode* tmpNode = nextNode->next;\n\n            nextNode->next = curNode;\n\n            curNode = nextNode;\n\n            nextNode = tmpNode;\n        }\n\n        return curNode;\n    }\n};\n```\n\n以上写法有一个瑕疵，我们在一个循环中增加了 curNode 是否为 head 的条件判断，会使得这个条件判断执行多次。为此，可以将 curNode 从 nullptr 开始定义，nextNode 定义为 head，这样就不需要在循环中处理特殊逻辑。\n\n```c++\nclass Solution \n{\npublic:\n    ListNode* reverseList(ListNode* head) \n    {\n        if(!head)\n        {\n            return nullptr;\n        }\n\n        ListNode* curNode = nullptr;\n        ListNode* nextNode = head;\n\n        while(nextNode)\n        {\n            ListNode* tmpNode = nextNode->next;\n\n            nextNode->next = curNode;\n\n            curNode = nextNode;\n\n            nextNode = tmpNode;\n        }\n        return curNode;\n    }\n};\n```\n\n# [3. 两数相加](https://leetcode.cn/problems/add-two-numbers/description/)\n\n给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例 1：**\n\n```\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n```\n\n**示例 2：**\n\n```\n输入：l1 = [0], l2 = [0]\n输出：[0]\n```\n\n**示例 3：**\n\n```\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n```\n\n**提示：**\n\n- 每个链表中的节点数在范围 `[1, 100]` 内\n- `0 <= Node.val <= 9`\n- 题目数据保证列表表示的数字不含前导零\n\n遍历两个链表，将每次迭代的结果求和放入新链表即可。注意两个链表的长度可能不一样，并且要处理进位问题。\n\n```c++\nclass Solution \n{\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \n    {\n        if(!l1 || !l2)\n        {\n            return nullptr;\n        }    \n\n        ListNode* resHead = nullptr;\n        ListNode* preNode = nullptr;\n        bool isCarry = false;\n\n        while(l1 || l2)\n        {\n            int curVal = 0;\n            if(l1)\n            {\n                curVal += l1->val;\n                l1 = l1->next;\n            }\n\n            if(l2)\n            {\n                curVal += l2->val;\n                l2 = l2->next;\n            }\n\n            if(isCarry)\n            {\n                curVal += 1;\n            }\n\n            if(curVal >= 10)\n            {\n                isCarry = true;\n            }\n            else\n            {\n                isCarry = false;\n            }\n            curVal = curVal % 10;\n\n            ListNode* tmpNode = new ListNode();\n            tmpNode->val = curVal;\n\n            if(!resHead)\n            {\n                resHead = tmpNode;\n                preNode = resHead;\n            }\n            else\n            {\n                preNode->next = tmpNode;\n                preNode = tmpNode;\n            }\n        }\n\n        if(isCarry)\n        {\n            ListNode* tmpNode = new ListNode();\n            tmpNode->val = 1;\n            preNode->next = tmpNode;\n        }\n\n        return resHead;\n    }\n};\n```\n\n# [4. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n\n给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。\n\n**示例 1:**\n\n```\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。注意 \"bca\" 和 \"cab\" 也是正确答案。\n```\n\n**示例 2:**\n\n```\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n      请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n**提示：**\n\n- `0 <= s.length <= 5 * 104`\n- `s` 由英文字母、数字、符号和空格组成\n\n\n\n我们边遍历该字符串，边建立一个字符和索引的哈希表。同时维护一个最长子串长度 res 和当前子串长度 cur 以及当前子串的开始索引 curBeginIndex。如果哈希表中没有当前字符，则当前子串长度自增，并放入哈希表中。\n\n如果哈希表中查到了当前字符，且当前索引要大于 curBeginIndex，则说明当前子串出现了重复。此时需要更新哈希表中的索引，当前子串的长度也求得为 `i - oldIndex`，当前子串的开始索引也需要更新为 `oldIndex + 1`。\n\n```c++\nclass Solution \n{\npublic:\n    int lengthOfLongestSubstring(string s) \n    {\n        std::unordered_map<char, int> chMap;\n        int res = 0, cur = 0, curBeginIndex = 0;\n        for(int i = 0; i < s.size(); ++i)\n        {\n            if(chMap.count(s[i]) && chMap[s[i]] >= curBeginIndex)\n            {\n                int oldIndex = chMap[s[i]];\n                chMap[s[i]] = i;\n                cur = i - oldIndex;\n                curBeginIndex = oldIndex + 1;\n            }\n            else\n            {\n                chMap[s[i]] = i;\n                ++cur;\n            }\n            res = std::max(res, cur);\n        }\n        return res;\n    }\n};\n```\n\n这本质上是一种滑动窗口的思想，我们可以用一种更清晰的写法：\n\n```c++\nclass Solution \n{\npublic:\n    int lengthOfLongestSubstring(string s) \n    {\n        std::unordered_map<char, int> chMap;\n        int res = 0, left = 0;\n        \n        for(int right = 0; right < s.size(); ++right) \n        {\n            if(chMap.count(s[right]) && chMap[s[right]] >= left) \n            {\n                left = chMap[s[right]] + 1;\n            }\n            chMap[s[right]] = right;\n            res = std::max(res, right - left + 1);\n        }\n        return res;\n    }\n};\n```\n\n注意到 `std::max(res, right - left + 1)` 这个写法，因为数组索引是从 0 开始的，所以计算长度的时候需要加1。比如 right 为 2，left 为 0 时，长度应该为3。left 和 right 框定的区域就是滑动窗口的区域，窗口向前滑动，left 和 right 按照一定规则变更，这就是滑动窗口的思想。","slug":"Coding-Problems","published":true,"updated":"2025-11-02T08:11:00.332Z","_id":"cmh7o11j60000r4cn5skl1af9","comments":true,"layout":"post","photos":[],"html":"<h1><a href=\"https://leetcode.cn/problems/two-sum/description/\">1. 两数之和</a></h1>\n<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>\n<p>你可以按任意顺序返回答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,7,11,15], target = 9</span><br><span class=\"line\">输出：[0,1]</span><br><span class=\"line\">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,4], target = 6</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,3], target = 6</span><br><span class=\"line\">输出：[0,1]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n<li><strong>只会存在一个有效答案</strong></li>\n</ul>\n<p>暴力方法，对于每一个 num，和 nums 中其他所有 num 计算 target 即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.<span class=\"built_in\">size</span>(); ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i] + nums[j] == target)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> &#123;i, j&#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>更高效率的方式是先将 nums 记录到一个哈希表中，遍历 num 时只需要在哈希表中查询 target - num。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        std::unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; resMap;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            resMap[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> val = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> iter = resMap.<span class=\"built_in\">find</span>(val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(iter != resMap.<span class=\"built_in\">end</span>() &amp;&amp; i != iter-&gt;second)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;i, iter-&gt;second&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上写法的不足之处在于构建哈希表时额外多了一次遍历，实际上可以边计算结果边构建，在遍历到其中一个 num 时不需要急于得出结果，只将其放入哈希表，因为后续一定会遍历到 target - num。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">       std::unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; resMap;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(resMap.<span class=\"built_in\">count</span>(target - nums[i]))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;i, resMap[target - nums[i]]&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                resMap[nums[i]] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode.cn/problems/UHnkqh/\">2. 反转链表</a></h1>\n<p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,3,4,5]</span><br><span class=\"line\">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2]</span><br><span class=\"line\">输出：[2,1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n<p>链表结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x, ListNode *next) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(next) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>定义一个 curNode 和一个指向 curNode 下一个节点的 nextNode，只需要将 nextNode 的 next 指针反向指向 curNode 即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* curNode = head;</span><br><span class=\"line\">        ListNode* nextNode = curNode-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(nextNode)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(curNode == head)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                curNode-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* tmpNode = nextNode-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">            nextNode-&gt;next = curNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            curNode = nextNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            nextNode = tmpNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> curNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上写法有一个瑕疵，我们在一个循环中增加了 curNode 是否为 head 的条件判断，会使得这个条件判断执行多次。为此，可以将 curNode 从 nullptr 开始定义，nextNode 定义为 head，这样就不需要在循环中处理特殊逻辑。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* curNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* nextNode = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(nextNode)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode* tmpNode = nextNode-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">            nextNode-&gt;next = curNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            curNode = nextNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            nextNode = tmpNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode.cn/problems/add-two-numbers/description/\">3. 两数相加</a></h1>\n<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class=\"line\">输出：[7,0,8]</span><br><span class=\"line\">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 = [0], l2 = [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class=\"line\">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n<p>遍历两个链表，将每次迭代的结果求和放入新链表即可。注意两个链表的长度可能不一样，并且要处理进位问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!l1 || !l2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* resHead = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* preNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"type\">bool</span> isCarry = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 || l2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> curVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                curVal += l1-&gt;val;</span><br><span class=\"line\">                l1 = l1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                curVal += l2-&gt;val;</span><br><span class=\"line\">                l2 = l2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isCarry)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                curVal += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(curVal &gt;= <span class=\"number\">10</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                isCarry = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                isCarry = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curVal = curVal % <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* tmpNode = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>();</span><br><span class=\"line\">            tmpNode-&gt;val = curVal;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!resHead)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                resHead = tmpNode;</span><br><span class=\"line\">                preNode = resHead;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                preNode-&gt;next = tmpNode;</span><br><span class=\"line\">                preNode = tmpNode;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isCarry)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode* tmpNode = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>();</span><br><span class=\"line\">            tmpNode-&gt;val = <span class=\"number\">1</span>;</span><br><span class=\"line\">            preNode-&gt;next = tmpNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> resHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/\">4. 无重复字符的最长子串</a></h1>\n<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。注意 &quot;bca&quot; 和 &quot;cab&quot; 也是正确答案。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">      请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>\n<li><code>s</code> 由英文字母、数字、符号和空格组成</li>\n</ul>\n<p>我们边遍历该字符串，边建立一个字符和索引的哈希表。同时维护一个最长子串长度 res 和当前子串长度 cur 以及当前子串的开始索引 curBeginIndex。如果哈希表中没有当前字符，则当前子串长度自增，并放入哈希表中。</p>\n<p>如果哈希表中查到了当前字符，且当前索引要大于 curBeginIndex，则说明当前子串出现了重复。此时需要更新哈希表中的索引，当前子串的长度也求得为 <code>i - oldIndex</code>，当前子串的开始索引也需要更新为 <code>oldIndex + 1</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        std::unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; chMap;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>, cur = <span class=\"number\">0</span>, curBeginIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(chMap.<span class=\"built_in\">count</span>(s[i]) &amp;&amp; chMap[s[i]] &gt;= curBeginIndex)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> oldIndex = chMap[s[i]];</span><br><span class=\"line\">                chMap[s[i]] = i;</span><br><span class=\"line\">                cur = i - oldIndex;</span><br><span class=\"line\">                curBeginIndex = oldIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                chMap[s[i]] = i;</span><br><span class=\"line\">                ++cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = std::<span class=\"built_in\">max</span>(res, cur);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这本质上是一种滑动窗口的思想，我们可以用一种更清晰的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        std::unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; chMap;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>, left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> right = <span class=\"number\">0</span>; right &lt; s.<span class=\"built_in\">size</span>(); ++right) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(chMap.<span class=\"built_in\">count</span>(s[right]) &amp;&amp; chMap[s[right]] &gt;= left) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = chMap[s[right]] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            chMap[s[right]] = right;</span><br><span class=\"line\">            res = std::<span class=\"built_in\">max</span>(res, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意到 <code>std::max(res, right - left + 1)</code> 这个写法，因为数组索引是从 0 开始的，所以计算长度的时候需要加1。比如 right 为 2，left 为 0 时，长度应该为3。left 和 right 框定的区域就是滑动窗口的区域，窗口向前滑动，left 和 right 按照一定规则变更，这就是滑动窗口的思想。</p>\n","excerpt":"","more":"<h1><a href=\"https://leetcode.cn/problems/two-sum/description/\">1. 两数之和</a></h1>\n<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>\n<p>你可以按任意顺序返回答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,7,11,15], target = 9</span><br><span class=\"line\">输出：[0,1]</span><br><span class=\"line\">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,4], target = 6</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,3], target = 6</span><br><span class=\"line\">输出：[0,1]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n<li><strong>只会存在一个有效答案</strong></li>\n</ul>\n<p>暴力方法，对于每一个 num，和 nums 中其他所有 num 计算 target 即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.<span class=\"built_in\">size</span>(); ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i] + nums[j] == target)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> &#123;i, j&#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>更高效率的方式是先将 nums 记录到一个哈希表中，遍历 num 时只需要在哈希表中查询 target - num。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        std::unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; resMap;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            resMap[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> val = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> iter = resMap.<span class=\"built_in\">find</span>(val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(iter != resMap.<span class=\"built_in\">end</span>() &amp;&amp; i != iter-&gt;second)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;i, iter-&gt;second&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上写法的不足之处在于构建哈希表时额外多了一次遍历，实际上可以边计算结果边构建，在遍历到其中一个 num 时不需要急于得出结果，只将其放入哈希表，因为后续一定会遍历到 target - num。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">       std::unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; resMap;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(resMap.<span class=\"built_in\">count</span>(target - nums[i]))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;i, resMap[target - nums[i]]&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                resMap[nums[i]] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode.cn/problems/UHnkqh/\">2. 反转链表</a></h1>\n<p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,3,4,5]</span><br><span class=\"line\">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2]</span><br><span class=\"line\">输出：[2,1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n<p>链表结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x, ListNode *next) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(next) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>定义一个 curNode 和一个指向 curNode 下一个节点的 nextNode，只需要将 nextNode 的 next 指针反向指向 curNode 即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* curNode = head;</span><br><span class=\"line\">        ListNode* nextNode = curNode-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(nextNode)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(curNode == head)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                curNode-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* tmpNode = nextNode-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">            nextNode-&gt;next = curNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            curNode = nextNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            nextNode = tmpNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> curNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上写法有一个瑕疵，我们在一个循环中增加了 curNode 是否为 head 的条件判断，会使得这个条件判断执行多次。为此，可以将 curNode 从 nullptr 开始定义，nextNode 定义为 head，这样就不需要在循环中处理特殊逻辑。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* curNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* nextNode = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(nextNode)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode* tmpNode = nextNode-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">            nextNode-&gt;next = curNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            curNode = nextNode;</span><br><span class=\"line\"></span><br><span class=\"line\">            nextNode = tmpNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode.cn/problems/add-two-numbers/description/\">3. 两数相加</a></h1>\n<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class=\"line\">输出：[7,0,8]</span><br><span class=\"line\">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 = [0], l2 = [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class=\"line\">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n<p>遍历两个链表，将每次迭代的结果求和放入新链表即可。注意两个链表的长度可能不一样，并且要处理进位问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!l1 || !l2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* resHead = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* preNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"type\">bool</span> isCarry = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 || l2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> curVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                curVal += l1-&gt;val;</span><br><span class=\"line\">                l1 = l1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                curVal += l2-&gt;val;</span><br><span class=\"line\">                l2 = l2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isCarry)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                curVal += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(curVal &gt;= <span class=\"number\">10</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                isCarry = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                isCarry = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curVal = curVal % <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* tmpNode = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>();</span><br><span class=\"line\">            tmpNode-&gt;val = curVal;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!resHead)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                resHead = tmpNode;</span><br><span class=\"line\">                preNode = resHead;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                preNode-&gt;next = tmpNode;</span><br><span class=\"line\">                preNode = tmpNode;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isCarry)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode* tmpNode = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>();</span><br><span class=\"line\">            tmpNode-&gt;val = <span class=\"number\">1</span>;</span><br><span class=\"line\">            preNode-&gt;next = tmpNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> resHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/\">4. 无重复字符的最长子串</a></h1>\n<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。注意 &quot;bca&quot; 和 &quot;cab&quot; 也是正确答案。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">      请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>\n<li><code>s</code> 由英文字母、数字、符号和空格组成</li>\n</ul>\n<p>我们边遍历该字符串，边建立一个字符和索引的哈希表。同时维护一个最长子串长度 res 和当前子串长度 cur 以及当前子串的开始索引 curBeginIndex。如果哈希表中没有当前字符，则当前子串长度自增，并放入哈希表中。</p>\n<p>如果哈希表中查到了当前字符，且当前索引要大于 curBeginIndex，则说明当前子串出现了重复。此时需要更新哈希表中的索引，当前子串的长度也求得为 <code>i - oldIndex</code>，当前子串的开始索引也需要更新为 <code>oldIndex + 1</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        std::unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; chMap;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>, cur = <span class=\"number\">0</span>, curBeginIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(chMap.<span class=\"built_in\">count</span>(s[i]) &amp;&amp; chMap[s[i]] &gt;= curBeginIndex)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> oldIndex = chMap[s[i]];</span><br><span class=\"line\">                chMap[s[i]] = i;</span><br><span class=\"line\">                cur = i - oldIndex;</span><br><span class=\"line\">                curBeginIndex = oldIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                chMap[s[i]] = i;</span><br><span class=\"line\">                ++cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = std::<span class=\"built_in\">max</span>(res, cur);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这本质上是一种滑动窗口的思想，我们可以用一种更清晰的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        std::unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; chMap;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>, left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> right = <span class=\"number\">0</span>; right &lt; s.<span class=\"built_in\">size</span>(); ++right) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(chMap.<span class=\"built_in\">count</span>(s[right]) &amp;&amp; chMap[s[right]] &gt;= left) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = chMap[s[right]] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            chMap[s[right]] = right;</span><br><span class=\"line\">            res = std::<span class=\"built_in\">max</span>(res, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意到 <code>std::max(res, right - left + 1)</code> 这个写法，因为数组索引是从 0 开始的，所以计算长度的时候需要加1。比如 right 为 2，left 为 0 时，长度应该为3。left 和 right 框定的区域就是滑动窗口的区域，窗口向前滑动，left 和 right 按照一定规则变更，这就是滑动窗口的思想。</p>\n","path":"2025/10/26/Coding-Problems/","permalink":"https://zweireverberate.space/2025/10/26/Coding-Problems/","tags":[{"name":"Algorithm","_id":"cmh7o11jb0001r4cn6kknbc7r","slug":"Algorithm","path":"tags/Algorithm/","permalink":"https://zweireverberate.space/tags/Algorithm/","length":1}],"categories":[],"prev":{"title":"C++ General","date":"2025-11-09T14:59:09.000Z","summary":"C++ 通义","slug":"C-General","published":true,"updated":"2025-11-12T16:06:20.156Z","_id":"cmhrudxky00005kcn5jz2f7fa","layout":"post","photos":[],"excerpt":"","path":"2025/11/09/C-General/","permalink":"https://zweireverberate.space/2025/11/09/C-General/","__post":true},"next":null,"__post":true}