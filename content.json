{"pages":[{"title":"About","text":"联系方式：ziqiu370@gmail.com","link":"/about/index.html"}],"posts":[{"title":"素影微行","text":"人鱼传说 和那些古老而悠久传说不同，这个故事发生在千禧年伊始。 每当回想起记忆中的那个年代，总有些无法言明的清新意味。 我就是在那时候遇到她的。 当时，鱼贩的刀正悬在她的头上，晶莹的眼泪无声滑落， 是我买下了她，以每斤五块钱的价格。 我没有鱼缸，好在她也不是金鱼，并不反对我将她放置在塑料盆里。 不过后来她得知这是我先前的洗脚盆时，还是将我臭骂了一通。 “所有的鱼都会说人话吗？” “你傻啊，除了我你见过会说话的鱼么？” 真是条不正常的鱼。 她第一次听我说“上网”时，吓得鱼肚皮整个都翻过来了。 现在却整天霸占我从垃圾场偶然得到的电脑，毫无做鱼的立场。 “你不想回到河里去吗？” “不想，回到河里还得自己找吃的，也上不了qq。” “喂，别用我的 qq 乱发消息。你不知道企鹅是吃鱼的么？” “可它现在是我的宠物欸。” 后来 qq 宠物关服的时候，她还为她的企鹅大哭了一场。 这样的日子持续了好多年，我还是每天游手好闲，无所事事。 曾经和我一样闲散青年都找到了各自的人生轨迹，只有我还在原点兜兜转转， 我明明活在这个世界上，却又觉得自己与世隔绝。 如果不是她陪我说话的话，我都怀疑自己会丧失语言功能。 我既没有工作也没有收入，找不到东西吃的时候也想着是不是可以把她吃掉。 她对此好像毫无自觉，每天依旧毫不客气地吃掉我一半的食物，然后用鱼尾巴扇我两个大耳刮子。 我有时候也会说些无厘头的话， “要不要游到南极去，这样你就可以见到真正的企鹅了。” “你是笨蛋吗？我可是淡水鱼，而且企鹅可是吃鱼的。” 会说人话的鱼正在教我现实主义，而且对企鹅的态度前后也差太多了吧。 就算我和她一直停留在原点，时间还是会带着我们往前走。 春日，我四处浪荡，她对人类的生活方式还充满好奇，自由主义之风还残存于此。 夏云，曾经的朋友们都各奔东西，因大瘟疫食物短缺的我不止一次动过吃掉她的念头。 秋水，百川灌河。无论是独裁的阴云还是革命的浪潮，我都和她静静地旁观着。 冬雪，银色世界下的我，也消融成了同样的颜色。 我一直在等待着，等待着她离去的一天。 因为冥冥中我有一种预感，她会离我而去。 那时候，我再也不用顾忌，一个人痛快地吃掉两人份的食物，一个人独占电脑， 然后跑去饭店，美滋滋地吃一顿半辈子都没再吃过的水煮鱼，狠狠地发泄这么多年来我对鱼的怨气。 可无论我怎么等，她就在那里。仿佛她才是这里的主人，这叫什么道理。 终于，我再也等不下去了，耳畔已经响起了死神的足音， 她守在我的身边，鱼鳍搭在我的手上，静静地望着我。 原来，我一直搞错了立场，是她在等待我的离去，而不是我在等待她的离去。 她用鱼鳍在我的手心画了一张太极图，她说这幅图概括了宇宙的精髓， 我定睛一看， 太极图的中央， 赫然是两条相互盘绕的鱼！ 秋儿的夏天 秋儿不喜欢夏天。 同时，她也不喜欢冬天和春天。 好吧，本来她想连同秋天一起讨厌的，但谁叫自己的名字里面有一个秋字呢？ 秋儿每年夏天都要去乡下祖父家。 是的，那是祖父的家，不是秋儿的家。 因为那里的小孩子都觉得秋儿是城里人，不想和她一起玩。 但是，城里的小孩子却说她是乡下人，也不想和她一起玩。 那秋儿的家究竟在哪里呢？ 她蹲在院子里，一边数着地上的蚂蚁，一边想着这样的事情。 祖父家的夏天真的非常难熬。 天气总是很热，秋儿拿着早就写好的暑假作业本当成扇子扇风，把作业本扇得皱巴巴的。 卫星电视只有十二个频道，秋儿看不了自己喜欢看卡通片。 厕所修在猪圈旁，又脏又臭，上厕所时猪还会从旁边探出头来。 每次上厕所秋儿都要犹豫很久，才能鼓起勇气。 吃早饭的时候，祖母都会多为弟弟准备一瓶牛奶。 秋儿根本不喜欢喝牛奶，但还是会觉得心里空落落的。 于是她抿着嘴唇低头吃饭，就好像自己根本就没看到一样。 夏天终于要结束了。 列车西行而去，秋儿心里却感到忐忑不安。 因为父母为了省一点车票钱，没有给她买票。 她按照父母的指示，暂时是混过了检票口。 她没有自己的座位，小小的身体挤在父母座位的中间，动一下都很艰难。 对面座位的大妈脱下鞋子，把脚搭在秋儿旁边，秋儿感觉难受极了。 不知过了多久，车厢恹恹欲睡时，不远处检票员的声音让秋儿一家清醒过来。 父母赶紧让她去厕所藏好。 秋儿没有办法，逃一般地跑向厕所。 不幸的是，厕所有人。秋儿就这样站在过道里手足无措。 检票员来到她的身边，温柔地询问她。 秋儿慌了神，领着检票员回到了父母的座位旁。 父母狠狠地瞪了她一眼，然后不得不补了票。 秋儿的小手紧紧攥着半价儿童票，目光却紧紧盯着窗外。 她在等待列车进入隧道的那一刻。 这样，别人就看不清她眼角泛起的星辉。 她叫秋儿，她的泪水便是秋雨。 百川西流去 对于那一天，可能没有谁比我的印象更为清晰。 彼时，我漫步在海边璀璨的星光里，连绵的海岸线在大江入海处被生生截断。 在某个走神的瞬间，天地失色，山海似乎将要崩裂。 回过神来时，大江已然逆流。 我停在原地观察许久，确认了这不是潮汐或者海啸，而是一种违反任何已知物理规则奇观。 水往高处流，这么形容其实并不准确。 只有在这条大江中，流水正在溯源而上。 顺水行舟，是再理所当然不过的事情。 就像年轻的时候，我沿着大江来到海滨。 如今，归去的渴望不住地在心里涌现。 这趟旅程并不如何辛苦。 流水本身就是方向，不会让我迷失。 更重要的是，这都是我曾经走过的路。 只是，看到飞流而上的瀑布，心里还是止不住地赞叹。 每当行至巍峨的高山时，只要跳进江中，大江自会助你前行。 越临近源头，越让我的心情难以平静。 因为那时，“我从哪里来” 的答案就会被揭晓。 我不确定自己是否做好了接受答案的准备。 但，百川西流去。 越过最后一座山峰，我看到太阳在此落下，这就是西行的终点。 江水汇聚成一片暗红色的海洋， 真正的黑夜包裹着高原上温暖的摇篮， 这种温暖，对每个生命来说都弥足珍贵，因为一生只能体验一次。 我将在第十个月时离开，纵然我会因不舍而放声啼哭。 到那时，百川东流去，生命将又将迎来开端。 这片暗红色的海洋，是母亲的子宫。 闹钟战士 作为闹钟的最大屈辱，就是服务的对象每天比自己更早醒来。 吾等是他的所有物，但并不承认他是吾之主人。 因为吾是一名战士，内部的钢铁核心镌刻着同困意作战的使命。 而他，从未将吾置于战场之上。这毫无疑问是对战士尊严的践踏。 据吾观察，他的行为模式极其古怪。 他总是在吾打鸣十分钟之前就醒来，然后将吾关掉。 晚上入睡前，又会坚持将吾设定到早上七点。 尽做些多余的事情。 吾觉得，他一定是生性多疑。 不仅不信任吾这样精密的现代机械，也不信任自己的生物钟，一定要双重保障才能放心。 他每天睡得一定很不踏实吧，可怜的人类。 但这就是不信任吾的代价。 吾从未想过，要面对除了困意之外的敌人。 长久以来，吾都将自己视为精密机械工业的光辉，哪怕未曾得到过发声的机会。 直到他第一次使用了&quot;Smart Phone&quot;而非吾来设定起床提醒。 吾之工艺相比于&quot;Smart Phone&quot;只能算是粗劣，而且设定起来亦不如其方便。 用来昭示自己存在价值的东西全部消失。 也许不久后，吾就会跟着其他布满灰尘的垃圾一样被遗弃。 每当想到这样的未来，心中就充满了恐惧。 现在的吾，同他一样，每天都睡不踏实。 但吾仍未忘记吾战士的身份，战士应该光明正大的战死。 吾向&quot;Smart Phone&quot;宣战，告诉它吾将于午夜发起进攻。 它无视了吾，但它很快将为此付出代价。 吾为闹钟，吾最强且唯一的武器只有响彻天际的声音。 但就是这样的武器，也被此时呼呼大睡的两脚生物被禁锢住了。 但吾的意志已经足够坚定，这种困难根本不值一提。 吾奇迹般地操纵电流从既定轨迹上偏移了一丝，引起的短路瞬间让吾充满能量。 这是吾平生最决然最响亮也是唯一一次的悲鸣，震碎了房间内所有的玻璃制品。 不可一世的&quot;Smart Phone&quot;也因此寸寸碎裂，吾满意地离开尘世，准备好奔赴另一个世界的战场。 吾最后看到他从震惊中醒来。 在吾一生一次的怒吼下，你还想安然入睡吗？ 碎叶之声 冬日的午后，寒意稍退，公园小径上的枯叶在微风中轻轻颤动。一踩上去，就发出悦耳的碎裂声。 但想必我已经不是第一次听到这种声音，只是到现在为止才将其视作一种具体而明确的事物。再细细思索，便能发觉记忆中许多片段都能同其连结起来。 人们常说的 “换个角度看世界” 也是同样的道理，在刻意的挖掘下，人的意识没有穷尽。 然而，这种观念上的充分演绎并无现实可行性。作为意志之表象的人本身通常缺乏完备自我实现的条件，同时也违背了经济性的原则。 从个体来看，只要达到了存在性的门槛，深入跃迁的动力就会大幅消退。而个体间的不充分发展，就是社会差异的根源。所谓的大千世界，是否只是无数并行但非同步的观念性暂留？ 个体会相互干涉，族群可以看作是这种干涉的结果。照此看，趋同已成定局。 当然，这个定局可能也是人为设定的终止条件。因为再考虑下去就会十分艰难并且无法描述。 我的笔友朱音（星屑的闪光）想必无法接受这样的说法，注重个性的朱音也许会说：“希望你做一个不改本色的好孩子”。 我一面这样想着，一边踏着碎叶走向公园深处。 白雪余痕 小满把头探出窗外，凛冽的冬风让她有些难受。 直到流下亮晶晶的鼻涕，她才满意地缩回身子，然后一脸傻笑地等着阿月来。 “小满，鼻涕要好好擦掉哦！” 还在发呆的小满没有注意到悄然而至的阿月，只觉得脸上都是好闻的面巾纸香味。 为小满擦好鼻涕后，阿月又帮她理好衣领，露出了温和的笑容。 今天的课文叫做《看雪》，两个小女孩的眼里都闪烁起银白色。 “为什么我们这里不会下雪呢？” “因为我们这里不够冷啦，雪就像冰糕一样冷哟。” “那雪的味道也和冰糕一样吗？” “是呀，不过小满不可以去尝哦，不然又要流鼻涕了。” 小满还想再说些傻乎乎的话，阿月的面巾纸却不由分说的盖住了她的鼻子，小满只能发出咿咿呜呜的声音。 大家都说小满傻，只有小满自己不这么觉得。 因为阿月是个好孩子，好孩子是不会放着笨蛋不管的。 所以当笨蛋也没关系啦！ 她其实早就见过真正的雪了，虽然这里是南方，但山上的老家到了冬天也会变成一片雪白。 那时候小满在雪地里蹦蹦跳跳，玩雪真的很开心。 可是一个人也会有点寂寞哦，雪花也尝不出冰糕的味道。 要是能带阿月一起过去玩雪就好了。到时候聪明伶俐的阿月会不会发现小满在骗她呢？ 好害羞呀！小满用被子捂住头，这样别人就看不到她红扑扑的脸蛋了。 小满其实不用担心被阿月发现的，因为阿月就要转学了。 小满哭得很伤心，阿月的面巾纸都用光了。 “小满不要哭啦，这个送给你，以后要自己好好擦鼻涕哦。” 小满看着阿月满是担心的目光，于是真的不哭了。 纸盒上写着一个“雪”字，是阿月写的，全班只有阿月的字这么好看。 无数晶莹剔透的雪花正在里面闪闪发光。 阿月的雪花真的和冰糕一样甜。既不冷也不会融化，想必是怕小满流鼻涕吧。 但那之后小满已经不流鼻涕了，此时的她正迎着冬风，一脸顽强地走着。","link":"/2989/06/04/%E7%B4%A0%E5%BD%B1%E5%BE%AE%E8%A1%8C/"},{"title":"司寤纪时","text":"《周礼·秋官》：司寤氏掌夜时。以星分夜，以诏夜士夜禁，御晨行者，禁宵行者、夜游者。 《尚书·洪范》：五纪。一曰岁，二曰月，三曰日，四曰星辰，五曰历数。 十年之始 (2025/08/18) 使用上个域名已逾五年，逐年递增的支出让我不禁开始思考续费的必要性。此处访问者寥寥，这一年亦没能写出什么像样的文字。春秋迭代，尘埃渐渐堆积。 曾强迫自己写了一年多日志，所以那时的记忆尤为清晰，回首仿若真能看到时间的隐隐痕迹。当时工于修辞，也无心记录日常琐事，故常常为此苦思冥想，耗费了许多心力，长此以往，便成了负担。从之前的公司离职后，失去生活规律的我，也同时失去了这个习惯。 闭源 App 取代开源 Web 是大势所趋，如果只是为了记录，有太多的选择。但最终还是愿意停留在自己觉得比较舒适的时代，一口气买了十年的域名。 之后还是想继续记录一些东西，这里就是开始。","link":"/7000/06/04/%E5%8F%B8%E5%AF%A4%E7%BA%AA%E6%97%B6/"},{"title":"Coding Problems","text":"1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 暴力方法，对于每一个 num，和 nums 中其他所有 num 计算 target 即可。 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { for(int i = 0; i &lt; nums.size()-1; ++i) { for(int j = i + 1; j &lt; nums.size(); ++j) { if(nums[i] + nums[j] == target) { return {i, j}; } } } return {}; }}; 更高效率的方式是先将 nums 记录到一个哈希表中，遍历 num 时只需要在哈希表中查询 target - num。 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { std::unordered_map&lt;int, int&gt; resMap; for(int i = 0; i &lt; nums.size(); ++i) { resMap[nums[i]] = i; } for(int i = 0; i &lt; nums.size(); ++i) { int val = target - nums[i]; auto iter = resMap.find(val); if(iter != resMap.end() &amp;&amp; i != iter-&gt;second) { return {i, iter-&gt;second}; } } return {}; }}; 以上写法的不足之处在于构建哈希表时额外多了一次遍历，实际上可以边计算结果边构建，在遍历到其中一个 num 时不需要急于得出结果，只将其放入哈希表，因为后续一定会遍历到 target - num。 1234567891011121314151617181920class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { std::unordered_map&lt;int, int&gt; resMap; for(int i = 0; i &lt; nums.size(); ++i) { if(resMap.count(target - nums[i])) { return {i, resMap[target - nums[i]]}; } else { resMap[nums[i]] = i; } } return {}; }}; 2. 反转链表 给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 链表结构： 12345678struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}}; 定义一个 curNode 和一个指向 curNode 下一个节点的 nextNode，只需要将 nextNode 的 next 指针反向指向 curNode 即可。 1234567891011121314151617181920212223242526272829303132class Solution {public: ListNode* reverseList(ListNode* head) { if(!head) { return nullptr; } ListNode* curNode = head; ListNode* nextNode = curNode-&gt;next; while(nextNode) { if(curNode == head) { curNode-&gt;next = nullptr; } ListNode* tmpNode = nextNode-&gt;next; nextNode-&gt;next = curNode; curNode = nextNode; nextNode = tmpNode; } return curNode; }}; 以上写法有一个瑕疵，我们在一个循环中增加了 curNode 是否为 head 的条件判断，会使得这个条件判断执行多次。为此，可以将 curNode 从 nullptr 开始定义，nextNode 定义为 head，这样就不需要在循环中处理特殊逻辑。 1234567891011121314151617181920212223242526class Solution {public: ListNode* reverseList(ListNode* head) { if(!head) { return nullptr; } ListNode* curNode = nullptr; ListNode* nextNode = head; while(nextNode) { ListNode* tmpNode = nextNode-&gt;next; nextNode-&gt;next = curNode; curNode = nextNode; nextNode = tmpNode; } return curNode; }}; 3. 两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 12输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 遍历两个链表，将每次迭代的结果求和放入新链表即可。注意两个链表的长度可能不一样，并且要处理进位问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { if(!l1 || !l2) { return nullptr; } ListNode* resHead = nullptr; ListNode* preNode = nullptr; bool isCarry = false; while(l1 || l2) { int curVal = 0; if(l1) { curVal += l1-&gt;val; l1 = l1-&gt;next; } if(l2) { curVal += l2-&gt;val; l2 = l2-&gt;next; } if(isCarry) { curVal += 1; } if(curVal &gt;= 10) { isCarry = true; } else { isCarry = false; } curVal = curVal % 10; ListNode* tmpNode = new ListNode(); tmpNode-&gt;val = curVal; if(!resHead) { resHead = tmpNode; preNode = resHead; } else { preNode-&gt;next = tmpNode; preNode = tmpNode; } } if(isCarry) { ListNode* tmpNode = new ListNode(); tmpNode-&gt;val = 1; preNode-&gt;next = tmpNode; } return resHead; }}; 4. 无重复字符的最长子串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。注意 &quot;bca&quot; 和 &quot;cab&quot; 也是正确答案。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 我们边遍历该字符串，边建立一个字符和索引的哈希表。同时维护一个最长子串长度 res 和当前子串长度 cur 以及当前子串的开始索引 curBeginIndex。如果哈希表中没有当前字符，则当前子串长度自增，并放入哈希表中。 如果哈希表中查到了当前字符，且当前索引要大于 curBeginIndex，则说明当前子串出现了重复。此时需要更新哈希表中的索引，当前子串的长度也求得为 i - oldIndex，当前子串的开始索引也需要更新为 oldIndex + 1。 1234567891011121314151617181920212223242526class Solution {public: int lengthOfLongestSubstring(string s) { std::unordered_map&lt;char, int&gt; chMap; int res = 0, cur = 0, curBeginIndex = 0; for(int i = 0; i &lt; s.size(); ++i) { if(chMap.count(s[i]) &amp;&amp; chMap[s[i]] &gt;= curBeginIndex) { int oldIndex = chMap[s[i]]; chMap[s[i]] = i; cur = i - oldIndex; curBeginIndex = oldIndex + 1; } else { chMap[s[i]] = i; ++cur; } res = std::max(res, cur); } return res; }}; 这本质上是一种滑动窗口的思想，我们可以用一种更清晰的写法： 1234567891011121314151617181920class Solution {public: int lengthOfLongestSubstring(string s) { std::unordered_map&lt;char, int&gt; chMap; int res = 0, left = 0; for(int right = 0; right &lt; s.size(); ++right) { if(chMap.count(s[right]) &amp;&amp; chMap[s[right]] &gt;= left) { left = chMap[s[right]] + 1; } chMap[s[right]] = right; res = std::max(res, right - left + 1); } return res; }}; 注意到 std::max(res, right - left + 1) 这个写法，因为数组索引是从 0 开始的，所以计算长度的时候需要加1。比如 right 为 2，left 为 0 时，长度应该为3。left 和 right 框定的区域就是滑动窗口的区域，窗口向前滑动，left 和 right 按照一定规则变更，这就是滑动窗口的思想。","link":"/2025/10/26/Coding-Problems/"},{"title":"C++ General","text":"1. C++ 设计准则 1. Philosophy 1. 保持代码直观清晰 123456class Date{public: Month month() const; // do int month(); // don't} 在上述示例中，前者是更好的写法，它的返回值是类型明确的，并且本身具有 const 限定。 1234567891011int index = -1;for(int i = 0; i &lt; v.size(); ++i){ if(v[i] == val) { index = i; break; }} // badauto it = std::find(std::begin(v), std::end(v), val); // better 使用 STL 能使代码更加清晰简洁，不易出错。有一句现代 C++ 谚语：如果你还在显式地使用循环，那么你就没有真正理解 STL 算法。 2. 遵循 ISO Standard 按照由国际标准化组织（ISO）制定并发布的《ISO/IEC 14882》C++ 标准来编写代码。 这意味着尽量避免依赖各编译器厂商（如 GCC、MSVC、Clang）提供的额外语法或库扩展，以保证代码在不同环境下都能编译和运行。 另外，需要注意 Undefined Behavior 和 Implementation‑Defined Behavior Undefined Behavior 指 C++ 标准未明确规定行为规范的代码操作，允许编译器自由处理。程序可能崩溃、产生错误结果、或看似正常运行实则存在隐患。程序应避免任何 UB。 未定义行为完整列表 Implementation‑Defined Behavior 指 C++ 标准允许编译器或运行时环境自由选择具体实现方式，但要求该行为必须被明确文档化。虽然具有平台依赖性，但结果是可预测的，由特定编译器的实现文档保证。 3. 注释应写明意图 12345for(const auto&amp; v : vec) {...} // (1)for(auto&amp; v : vec) {...} // (2)std::for_each(std::execution::par, vec.begin(), vec.end(), [](auto&amp; v) {...}); // (3) 上述示例中，(1) 与 (2) 的区别在于前者不会修改容器中的元素。 (3) 是使用并行的方式对容器中的每个元素执行一个操作。但是需要注意的小规模数据可能因线程调度开销导致性能下降，这种写法更适用于大规模数据。 总之，注释应阐明意图，指出应该做什么。 4. 保证程序的静态类型安全 C++ 是静态类型语言。即所有的变量或表达式的类型必须在编译时确定。静态类型安全要求编译器不仅知道其类型，还要能检测出类型相关的错误。C++ 并非完全类型安全，因此需要在编写代码时人工规避问题。 以下是常见的类型安全的问题及规避方案： 联合体（Union） 联合体允许不同类型共享同一内存空间，同一时间只能存储一个成员的值，可以达到节省内存的效果，union 的大小等于其最大成员的大小； union 不记录当前活跃的成员，访问错误的成员会导致未定义行为。 123456789union Data { int i; float f;};Data data;data.i = 10;std::cout &lt;&lt; data.f &lt;&lt; std::endl; // 错误：此时通过 f 访问是未定义行为 在 C++11 之前，union 仅支持平凡类型。C++11 之后可以包含非平凡类型，但有严格限制。必须提供自定义构造函数，因为 union 的默认构造函数是 delete 状态。 123456789101112131415#include &lt;string&gt;union MyUnion { int i; std::string s; // 非平凡类型 // 编译器不会生成默认构造函数 // MyUnion() = delete;};int main() { // MyUnion u; // 错误,默认构造函数被删除 return 0;} 必须显式管理生命周期和追踪活跃成员，比如析构时需要识别出活跃成员，否则析构出错会有未定义行为。 C++17 引入了 std::variant，它是一个类型安全的联合体。可以方便地存储非平凡类型，并且自动管理存储资源的生命周期，是 union 的上位替代。 12345678910std::variant&lt;int, std::string&gt; v = &quot;hello&quot;;// 需要知道类型进行访问std::cout &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; std::endl;// 类型安全的访问方式if (auto* str = std::get_if&lt;std::string&gt;(&amp;v)) { std::cout &lt;&lt; *str &lt;&lt; std::endl;} 类型转换 显式类型转换（如 static_cast、dynamic_cast、reinterpret_cast、const_cast）可能引发错误或未定义行为 dynamic_cast 相对安全，有运行时类型检查。对于指针类型，转换失败会返回空指针；对于引用类型，转换失败会抛出 std::bad_cast 异常。 而基于模板的泛型代码减少了对类型转换的需求，从某种程度上可以减少此类错误。 数组退化 C 风格数组在传递给函数时，会退化为指向其首元素的指针，丢失数组大小信息。 123456void processArray(int arr[]) { // 这里 arr 实际上是指针，不是数组 // 输出指针大小(8/4字节)，无法获取原始数组大小 std::cout &lt;&lt; &quot;Size in function: &quot; &lt;&lt; sizeof(arr) &lt;&lt; std::endl; } C++20 提供的 std::span 是一个轻量级的视图，包含指针和大小信息，提供安全的数组访问，可以解决这个问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;span&gt;#include &lt;vector&gt;#include &lt;array&gt;// 使用 std::span 接收数组，自动保持大小信息void processWithSpan(std::span&lt;int&gt; arr) { std::cout &lt;&lt; &quot;Span size: &quot; &lt;&lt; arr.size() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Span data: &quot;; for (int value : arr) { std::cout &lt;&lt; value &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; // 安全的索引访问 for (size_t i = 0; i &lt; arr.size(); i++) { std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; // 子视图，同样安全 if (arr.size() &gt;= 3) { auto subspan = arr.subspan(1, 2); // 从索引1开始，取2个元素 std::cout &lt;&lt; &quot;Subspan: &quot;; for (int val : subspan) { std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; }}int main() { // 1. C 风格数组，自动推导大小 int cArray[] = { 1, 2, 3, 4, 5 }; processWithSpan(cArray); // 2. std::array std::array&lt;int, 4&gt; stdArray = { 6, 7, 8, 9 }; processWithSpan(stdArray); // 3. std::vector std::vector&lt;int&gt; vec = { 10, 11, 12, 13, 14 }; processWithSpan(vec); // 4. 动态数组，需要显式提供大小 int* dynamicArray = new int[3] {15, 16, 17}; processWithSpan(std::span&lt;int&gt;(dynamicArray, 3)); delete[] dynamicArray; return 0;} 需要注意的是，动态数组的大小在运行时确定，编译期无法推导，所以需要显式提供大小。而 std::vector 因为它本身是包含 size 信息的完整类型，所以即使其 size 是在运行期确定的，也无需向 std::span 显式提供大小。 窄化转换 隐式转换可能导致数据丢失（如 double → int 截断小数） 使用 {} 初始化（列表初始化）时，编译器会强制检查并拒绝窄化转换，帮助在编译期捕获此类错误。 5. 优先编译期检查而非运行期检查 所有能够在编译期进行的检查，都应当置于编译期完成。C++11 引入编译期断言 static_assert ，它接受一个常量表达式，在编译期验证条件，对条件不满足或者运行期才能确定的表达式产生编译错误。 此外，类型特征库（type-traits library）允许开发者构建强大的条件检查：例如static_assert(std::is_integral&lt;T&gt;::value)。 6. 无法在编译期检查的内容，应当能够在运行期进行检查 借助 dynamic_cast，我们能够安全地在继承层次结构中向上、向下及横向转换类的指针和引用。如果转换失败，对于指针会返回 nullptr，对于引用则会抛出 std::bad_cast 异常 dynamic_cast 依赖于运行时类型信息（Run-Time Type Information, RTTI），而 RTTI 只对多态类型（即包含虚函数的类）可用。 编译器在 vtable 中嵌入 type_info 对象，非多态类类型没有 vtable，因此没有存储类型信息的地方，dynamic_cast 通过查询对象的 type_info 来验证转换的合法性 7. 尽早捕获运行期错误 可采用多种对策消除运行时错误。比如检查指针、数组范围、类型转换等，避免错误的传播和扩散。 8. 不要泄露任何资源 资源不仅指内存，还包括系统资源，如文件句柄、网络套接字、数据库连接、图形界面句柄、互斥锁等 任何资源如果只申请不释放，都会随着程序的运行而不断累积。对于需要长时间运行的服务端程序或后台进程，即使是微小的泄露，最终也可能耗尽系统资源，导致程序崩溃或系统变得不稳定。 处理资源的惯用方法是 RAII (Resource Acquisition Is Initialization)： 将资源的生命周期与一个对象的生命周期绑定 在对象的构造函数中获取资源 在对象的析构函数中释放资源 C++保证，当对象离开其作用域时（无论是正常离开，还是因为异常而离开），其析构函数一定会被自动调用，无需手动干预 成员对象的析构函数在持有它的类析构时会自动调用，但它持有的资源是否需要手动释放，取决于该成员类型本身的实现 RAII 应用示例： 锁：如 std::lock_guard 或 std::unique_lock。在构造时锁定互斥量，在析构时自动解锁。这防止了因忘记解锁而导致的死锁 智能指针：如 std::unique_ptr 和 std::shared_ptr。它们包装了原始指针，在析构时自动释放所指向的内存。这是现代C++取代 new/delete 的首选方式 STL容器：如 std::vector, std::string 等。它们在析构时会自动清理其内部动态分配的所有元素和内存缓冲区，无需手动管理 9. 不要浪费时间和空间 需要有意识地避免不必要的时间和空间开销。比如以下例子： 1234567void lower(std::string s) { for (unsigned int i = 0; i &lt;= std::strlen(s.data()); ++i) { s[i] = std::tolower(s[i]); }} 该函数想将字符串 s 转换为小写字符，但有以下问题： 时间开销：std::strlen(s.data()) 在每次循环迭代时都会被调用。strlen 是一个 O(n) 复杂度的函数，它需要遍历整个字符串直到找到空终止符 \\0。这导致一个原本是 O(n) 的循环变成了 O(n²)，对于长字符串会造成巨大的性能浪费 传参错误：应传引用，传值并没有改动 s，并造成了额外的拷贝 使用 std::transform 可以解决上述问题： 12std::transform(s.begin(), s.end(), s.begin(), [](char c) { return std::tolower(c); }); 下一个例子是抑制移动语义： 12345678910struct S { std::string s_; S(std::string s): s_(s) {} S(const S&amp; rhs): s_(rhs.s_) {} S&amp; operator = (const S&amp; rhs) { s_ = rhs.s_; return *this; }};S s1;S s2 = std::move(s1); // 这里执行的是拷贝，而非从 s1.s_ 移动 C++11 引入了移动语义，通过移动构造函数和移动赋值运算符实现。它将资源从一个临时对象（通常是右值）移动过来，而不是复制，成本低廉。 但是在这个例子中，用户手动定义了拷贝构造函数和拷贝赋值运算符。根据C++标准规则，一旦用户显式定义了这些拷贝操作，编译器就不会自动生成默认的移动操作（移动构造函数和移动赋值运算符）。 但可以通过= default显式要求编译器生成移动操作 因此，在代码 S s2 = std::move(s1); 中，std::move(s1) 本意是将 s1 转换为一个右值，期望触发移动操作。但由于 S 没有移动构造函数，编译器只能退而求其次，调用拷贝构造函数。这里的 std::move 实际上没有起到任何加速作用，反而产生了昂贵的拷贝开销。 现代C++的最佳实践是“零规则”(Rule of Zero)：尽量避免手动定义拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符和析构函数。让编译器为你生成所有这些默认操作。在无需直接管理资源的大多数情况下，编译器生成的都是正确且最优的。 如果类需要直接管理资源，确实需要自定义这些操作，那么应遵循 “五规则”(Rule of Five)：如果需要自定义其中任何一个，那么很可能需要同时自定义所有五个（拷贝构造、移动构造、拷贝赋值、移动赋值、析构），并正确地实现它们。 10. 优先使用不可变数据而非可变数据 不可变数据（常量）有以下优势： 固化状态流转路径，降低代码复杂度 利于编译期优化：包括常量传播、公共子表达式消除、死代码删除等编译优化技术 并发安全 11. 封装杂乱的构造，而非将其散布在代码中 如果有可能，尽量不要自己实现复杂易错的底层代码，优先考虑类似 STL 这样的成熟代码库。 如果找不到现成的高级库来替代必要的复杂逻辑，尽量将混乱、易变的细节隐藏在简洁的接口之中。 12. 根据需要使用辅助工具 使用如静态分析工具、并发分析工具、测试工具等辅助工具，可有效提高代码的正确性，可移植性和健壮性。 不同的编译器（如 GCC, Clang, MSVC）对 C++ 标准的实现和理解略有不同，使用多种 C++ 编译器来编译代码，也是很好的验证代码的方式。 13. 根据需要使用支持库 根据需要使用高质量外部库可避免重复造轮子，提升开发效率和代码质量。 2. Interfaces 1. 避免使用非 const 的全局变量 全局变量向函数内部注入了一个隐藏的依赖项，并且这个依赖项并非接口的一部分，容易出错，并且存在并发安全问题。 2. 谨慎使用单例 从本质上讲，单例也是一种全局变量。虽然它在很多场景下是有必要的，但我们在使用时也需要考虑以下问题： 谁负责销毁单例？ 应该允许单例派生吗？ 如何以线程安全的方式初始化单例？ 当单例相互依赖且位于不同的编译单元时，它们的初始化顺序是怎样的？（静态初始化顺序问题） 3. 书写好的接口 好的接口应遵循以下规则： 明确 强类型 尽可能少的参数 避免相邻的、不相关的同类型参数 结构体传参是一种好的写法，将复杂的参数列表封装为一个 struct，既很好地满足了上述规则，还使得接口的调整变得容易。如果接口需要新的参数，只需要在 struct 新增一个给出默认值的参数即可，所有的老代码依然正常调用，而无需到处修改。如： 12345678struct Light{ string name; vec3 color; int type; double brightNess = .0; // 令 brightNess 默认为 0 vec3 loc;}; 而所有的老代码依然可以正常调用，未指定的 brightNess 会具有默认值 .0 1void buildLightPass({.name = &quot;Light1&quot;, .color = {1, 1, 1}, .type = 1, .loc = {.0, .0, .0}}); 同理，如果有必要的话，返回值也可以定义为结构体。 对于返回值可能为空的的函数，或许空值语义是一种更好的写法。C++17 引入了 std::optional，形如 std::optional&lt;T&gt; 的类型有两种可能的状态：为空nullopt 和有值。这是一种语义更加明确的设计。 4. 不要以指针的方式传递数组 当我们将数组传递给一个入参是指针的函数时，数组会自动退化为其首元素的指针，所以往往还需要传递数组的大小。 这是一种容易出错的写法，如果有可能的话使用 std::vector 作为函数的入参更好，但如果场景中为了满足入参不得不拷贝数据，从数组创建 std::vector，std::span 将是更好的选择。 5. 为了稳定的 ABI，可考虑 Pimpl Pimpl（Pointer to Implementation）是 C++ 中的一种编译时封装技术，通过将类的实现细节隐藏在一个指向实现类的指针后面来减少编译依赖和提高封装性。 ABI 是二进制程序组件之间的接口，它定义了： 内存布局：类/结构体的大小、成员偏移量 函数调用约定：参数传递方式、栈清理责任 名称修饰：C++ 函数名在二进制中的表示方式 异常处理机制：异常如何抛出和捕获 虚函数表布局：多态类的运行时结构 基本结构 1234567891011class MyClass {public: MyClass(); ~MyClass(); void publicMethod(); private: class Impl; // 前向声明 std::unique_ptr&lt;Impl&gt; m_pImpl; // 指向实现的指针}; Pimpl 主要优势有两个： 分离定义，加速编译（修改了具体实现 Impl，只需要重新编译 MyClass.cpp） 可以保持 ABI 的稳定性，方便发布库更新和插件热装载 其代价是每次访问实现都有一次指针间接寻址，有极轻微的性能损失，代码结构更加复杂。适用于大型类（有很多的私有成员和方法），库开发（需要保持二进制的兼容性），编译时间敏感等场景。 3. Functions 1. 函数定义 定义一个函数首先需要考虑如何命名，好的函数命名并无铁律，不过这里仍有三条实用的建议： 取有意义的名字 函数应该执行单个逻辑操作 保持函数简洁 如果一个函数在编译期求值，应将其声明为 constexpr： 当在一个常量表达式中调用 constexpr 函数，或者将其结果赋值一个 constexpr 变量时，它会在编译期执行 constexpr 函数并非只能在编译期执行，当传递给它的参数是运行时才能确定的，或者没有强制要求结果是常量，那么它将退化成在运行时执行 当函数在编译期执行完成后，计算结果作为一个普通的字面常量存储在 ROM(Read Only Memory) 中，通常对应可执行文件中的 .rodata 段（只读数据段） constexpr 函数是隐式内联的，这意味着可以（并且通常应该将 constexpr 函数的定义写在头文件中） 如果是普通函数，那么编译器并不需要知道函数的具体实现，因为链接器 (Linker) 稍后会负责找到它。 但如果是 constexpr 函数，函数的完整定义必对当前编译的文件可见。最简单直接的方式就是将完整定义写在头文件里（也有一些其他实现方法：如 C++ 20 Modules，Untiy Build[单编译单元构建]等） 引申：如果是一个普通函数的定义写在了头文件里，是一种禁忌： 当两个 .cpp 源文件都包含这个头文件时，将分别生成两个同名符号，链接器在链接时无法区分，于是报错Multiple definition of 'add'（重定义错误） 这违背了 ODR（One Definition Rule，单一定义规则）：一个非内联函数在整个程序中只能有一个定义 inline 现在真正的作用是让多个翻译单元共享同一个定义，突破单一定义规则，可以解决这个问题 constexpr 函数天然线程安全 如果函数不会抛出异常，应将其声明为 noexcept 2. C++ 基础 1. 平凡类型（Trivial Type） C++11 引入平凡类型的概念，用于描述“没有副作用的构造/析构/赋值等操作”的类型，一个类型是平凡类型当且仅当它满足以下所有条件： 无用户定义的构造函数 无用户定义的析构函数 无用户定义的拷贝/移动构造函数 无用户定义的拷贝/移动赋值操作符 无虚函数，无虚基类 所有非静态成员和基类都是平凡的 可使用 std::is_trivial 进行判别。 POD 类型（Plain Old Data）相比于平凡类型是一个更严格、更古老的限制。在平凡类型的基础上还有标准布局（Standard Layout）的要求。 标准布局类型满足以下条件： 所有非静态成员具有相同的访问控制 无虚函数，无虚基类 没有引用类型的非静态数据成员 所有非静态数据成员都是标准布局类型 所有基类都是标准布局类型 满足以下继承条件之一： 没有基类 只有一个基类且没有非静态数据成员 基类和派生类中不能同时有非静态数据成员 可使用 std::is_standard_layout_v 判别是否是标准布局类型。 POD 类型也有 std::is_pod 这样的判断方法，但是该方法已经在 C++20 中被移除，不推荐使用。可通过 std::is_standard_layout_v 和 std::is_trivial 的组合来达到相同的目的。即： POD = Trivial &amp;&amp; Standard Layout 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;type_traits&gt;template&lt;typename T&gt;void checkTypeProperties() { std::cout &lt;&lt; &quot;Type: &quot; &lt;&lt; typeid(T).name() &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;Is trivial: &quot; &lt;&lt; std::is_trivial_v&lt;T&gt; &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;Is standard layout: &quot; &lt;&lt; std::is_standard_layout_v&lt;T&gt; &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;Is POD: &quot; &lt;&lt; std::is_pod_v&lt;T&gt; &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;---\\n&quot;;}// POD类型struct POD_Example { int a; char b;};// 平凡但非PODstruct TrivialNonPOD1 { public: int public_member;private: int private_member;};// 继承破坏标准布局struct TrivialNonPOD2 : POD_Example { int additional_member;};int main() { checkTypeProperties&lt;POD_Example&gt;(); checkTypeProperties&lt;TrivialNonPOD1&gt;(); checkTypeProperties&lt;TrivialNonPOD2&gt;(); return 0;} 应用场景 平凡类型 其核心特性在于可以使用 memcpy 等低级内存操作进行复制，而不需要逐个调用拷贝构造函数，在需要高效移动和复制时很有用。 1234567891011121314151617181920212223242526272829303132333435// 高效内存复制template&lt;typename T&gt;void trivial_copy(const T* src, T* dest, size_t count) { static_assert(std::is_trivial_v&lt;T&gt;, &quot;Type must be trivial for memcpy operations&quot;); std::memcpy(dest, src, count * sizeof(T));}// 序列化/反序列化struct TrivialData { int id; double value; char name[32];};void serialize_trivial(const TrivialData&amp; data, char* buffer) { // 安全地直接复制内存 std::memcpy(buffer, &amp;data, sizeof(TrivialData));}// 对象池和内存管理template&lt;typename T&gt;class ObjectPool { static_assert(std::is_trivial_v&lt;T&gt;, &quot;ObjectPool requires trivial types for efficient reuse&quot;); std::vector&lt;T&gt; pool;public: T* allocate() { // 可以安全地重用内存而不调用析构函数 return &amp;pool.emplace_back(); }}; 标准布局类型 其核心特性是确定性的内存布局，并与 C 语言兼容 12345678910111213141516171819202122232425262728293031323334353637383940414243// 与C语言互操作extern &quot;C&quot; { struct CStruct { int x; double y; }; void process_c_struct(CStruct* data);}struct CompatibleCppStruct { int x; double y;}; // 标准布局，可以与C结构体安全互操作static_assert(std::is_standard_layout_v&lt;CompatibleCppStruct&gt;);// 硬件寄存器映射struct DeviceRegisterMap { volatile uint32_t control; volatile uint32_t status; volatile uint32_t data;}; // 标准布局确保成员顺序与硬件寄存器一致// 网络协议数据包#pragma pack(push, 1)struct NetworkPacket { uint16_t header; uint32_t sequence; uint8_t payload[1024]; uint16_t checksum;}; // 标准布局 + 打包确保精确的内存布局#pragma pack(pop)// 通过偏移量访问成员template&lt;typename T, typename M&gt;size_t member_offset(M T::*member) { static_assert(std::is_standard_layout_v&lt;T&gt;); return reinterpret_cast&lt;size_t&gt;(&amp;(reinterpret_cast&lt;T*&gt;(0)-&gt;*member));} // 只有标准布局类型才有确定的成员偏移量 POD 类型 同时拥有以上两种类型的特性，是二者的交集。但现代 C++ 编码中应尽量避免使用这个概念。 Reference C++ Core Guidelines Explained: Best Practices for Modern C++ 现代 C++ 教程 小彭大典","link":"/2025/11/09/C-General/"}],"tags":[{"name":"Essay","slug":"Essay","link":"/tags/Essay/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[]}